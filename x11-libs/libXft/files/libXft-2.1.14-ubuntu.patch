diff -Naur libXft-2.1.14.orig/debian/changelog libXft-2.1.14/debian/changelog
--- libXft-2.1.14.orig/debian/changelog	1970-01-01 01:00:00.000000000 +0100
+++ libXft-2.1.14/debian/changelog	2010-02-20 14:45:51.000000000 +0100
@@ -0,0 +1,695 @@
+xft (2.1.14-1ubuntu1) lucid; urgency=low
+
+  * Merge from Debian unstable, remaining chnages:
+    - patches/100-libXft-2.1.10-lcd-filter-3.patch:
+      + Use new FreeType LCD colour filtering features, with additional
+        modification that the specific LCD Filter can be changed
+        (LP: #305399).
+  * Renumbered the patch to follow our unwritten policy.
+  * Drop patch 002_embeddedbitmap_property.patch, included upstream.
+
+ -- Timo Aaltonen <tjaalton@ubuntu.com>  Fri, 04 Dec 2009 16:02:38 +0200
+
+xft (2.1.14-1) unstable; urgency=low
+
+  [ Timo Aaltonen ]
+  * New upstream release.
+  * Bump the build-dep on xutils-dev (>= 1:7.5~1).
+  * Bump Standards-Version to 3.8.3 (README.source added).
+  * Drop pre-dependency on x11-common from libxft-dev. This was needed
+    for upgrades from sarge.
+  * Move -dbg package to section debug.
+
+ -- Julien Cristau <jcristau@debian.org>  Thu, 03 Dec 2009 14:40:25 +0100
+
+xft (2.1.13-3ubuntu1) jaunty; urgency=low
+
+  * Merge from debian unstable, remaining changes:
+    - debian/patches/002_embeddedbitmap_property.patch:
+      + Allow "embeddedbitmap" property in fontconfig.
+    - debian/patches/libXft-2.1.10-lcd-filter-3.patch:
+      + Use new FreeType LCD colour filtering features, with additional
+        modification that the specific LCD Filter can be changed
+        (LP: #305399).
+
+ -- Bryce Harrington <bryce@ubuntu.com>  Thu, 26 Feb 2009 13:40:39 -0800
+
+xft (2.1.13-3) unstable; urgency=low
+
+  * Upload to unstable.
+
+ -- Julien Cristau <jcristau@debian.org>  Sun, 15 Feb 2009 22:07:06 +0100
+
+xft (2.1.13-2ubuntu1) jaunty; urgency=low
+
+  * Merge from debian unstable, remaining changes:
+    - debian/patches/002_embeddedbitmap_property.patch:
+      + Allow "embeddedbitmap" property in fontconfig.
+    - debian/patches/libXft-2.1.10-lcd-filter-3.patch:
+      + Use new FreeType LCD colour filtering features, with additional
+        modification that the specific LCD Filter can be changed
+        (LP: #305399).
+
+ -- Anders Kaseorg <andersk@mit.edu>  Mon, 22 Dec 2008 00:50:15 -0500
+
+xft (2.1.13-2) experimental; urgency=low
+
+  * Delete obsolete libxft-dev preinst (closes: #491633).
+
+ -- Julien Cristau <jcristau@debian.org>  Sat, 26 Jul 2008 23:02:21 +0200
+
+xft (2.1.13-1) experimental; urgency=low
+
+  [ Brice Goglin ]
+  * Update upstream URL in debian/copyright.
+
+  [ Julien Cristau ]
+  * New upstream release.
+  * Stop handling nostrip explicitly in debian/rules (dh_strip does it
+    already), and allow parallel builds using sample code from policy.
+  * Switch to running autoreconf at build time; build-depend on automake,
+    libtool and xutils-dev.
+
+ -- Julien Cristau <jcristau@debian.org>  Sat, 19 Jul 2008 16:30:18 +0200
+
+xft (2.1.12-3ubuntu2) jaunty; urgency=low
+
+  * Fix build failure with new fontconfig, integrating the lcd-filter patch.
+
+ -- Matthias Klose <doko@ubuntu.com>  Tue, 18 Nov 2008 07:13:02 +0100
+
+xft (2.1.12-3ubuntu1) intrepid; urgency=low
+
+  * Merge from debian unstable, remaining changes:
+    - debian/patches/002_embeddedbitmap_property.patch:
+      + Allow "embeddedbitmap" property in fontconfig. (LP: 208745)
+    - debian/patches/libXft-2.1.10-lcd-filter-3.patch:
+      + Use new FreeType LCD colour filtering features, with additional
+        modification that the specific LCD Filter can be changed.
+    - Specify minimum versions for some depends
+    - Update maintainer field to Ubuntu
+
+ -- Bryce Harrington <bryce@ubuntu.com>  Tue, 17 Jun 2008 00:59:28 -0700
+
+xft (2.1.12-3) unstable; urgency=low
+
+  * Remove Branden from Uploaders with his permission.
+  * Bump Standards-Version to 3.7.3.
+  * Add Vcs-Git and Vcs-Browser control fields.
+  * Drop pre-dependency on x11-common from libxft2 and libxft2-dbg, as it's
+    not needed.
+  * Use ${binary:Version} instead of the equivalent but confusingly-named
+    ${Source-Version}.
+  * Modify patch 001_no_export_freetype.diff to not export fontconfig in
+    'pkg-config --libs xft' (closes: #389831).
+  * Add myself to Uploaders.
+  * Fix XftDrawRect when Render not supported (cherry-picked from upstream
+    git; closes: #462262).
+
+ -- Julien Cristau <jcristau@debian.org>  Tue, 10 Jun 2008 16:12:37 +0200
+
+xft (2.1.12-2ubuntu5) hardy; urgency=low
+
+  [Liu Qishuai]
+  * debian/patches/002_embeddedbitmap_property.patch:
+    - Allow "embeddedbitmap" property in fontconfig. (LP: #208745)
+  * debian/changelog:
+    - Update to Ubuntu maintainer
+
+ -- Bryce Harrington <bryce@ubuntu.com>  Wed, 09 Apr 2008 14:12:59 -0700
+
+xft (2.1.12-2ubuntu4) gutsy; urgency=low
+
+  * debian/patches/libXft-2.1.10-lcd-filter-3.patch:
+    - Restore patch that uses new FreeType LCD colour filtering features,
+      with additional modification that the specific LCD Filter can be
+      changed.
+
+ -- Scott James Remnant <scott@ubuntu.com>  Thu, 20 Sep 2007 20:09:10 +0100
+
+xft (2.1.12-2ubuntu3) gutsy; urgency=low
+
+  * debian/patches/series
+    - remove mention of libXft-2.1.10-lcd-filter-2.patch
+
+ -- Matthew Garrett <mjg59@srcf.ucam.org>  Thu, 20 Sep 2007 15:48:21 +0100
+
+xft (2.1.12-2ubuntu2) gutsy; urgency=low
+
+  * debian/patches/libXft-2.1.10-lcd-filter-2.patch:
+    - remove - results in incorrect rendering, and we have the bytecode
+      interpreter enabled anyway
+
+ -- Matthew Garrett <mjg59@srcf.ucam.org>  Thu, 20 Sep 2007 05:08:05 +0100
+
+xft (2.1.12-2ubuntu1) gutsy; urgency=low
+
+  [ Matti Lindell ]
+  * debian/patches/libXft-2.1.10-lcd-filter-2.patch:
+    - use new built-in FreeType LCD color filtering features
+
+ -- Scott James Remnant <scott@ubuntu.com>  Tue, 18 Sep 2007 17:39:18 +0100
+
+xft (2.1.12-2) unstable; urgency=low
+
+  * Upload to unstable.
+
+ -- Julien Cristau <jcristau@debian.org>  Tue, 10 Apr 2007 20:43:57 +0200
+
+xft (2.1.12-1) experimental; urgency=low
+
+  * New upstream release.
+  * Install the upstream ChangeLog.
+
+ -- Julien Cristau <jcristau@debian.org>  Fri,  9 Feb 2007 14:56:32 +0100
+
+xft (2.1.10-3) experimental; urgency=low
+
+  * Remove that explicit shlibs file added in the last upload. The only
+    symbols that are hidden are private, so if your app is using those symbols
+    it's being very naughty. Go back to just generating shlibs using
+    dh_makeshlibs.
+
+ -- David Nusinow <dnusinow@debian.org>  Thu, 24 Aug 2006 00:29:33 +0000
+
+xft (2.1.10-2) experimental; urgency=low
+
+  * Add shlibs file because the public API and exported symbols changed
+    between 2.1.8.2 and now
+
+ -- David Nusinow <dnusinow@debian.org>  Wed, 16 Aug 2006 20:34:41 +0000
+
+xft (2.1.10-1) experimental; urgency=low
+
+  * New upstream release.
+  * Test for obj-$(DEB_BUILD_GNU_TYPE) before creating it during build;
+    idempotency fix.
+  * Fix changelog to not make lintian upset.
+  * Drop patches/002_no_xproto_dep.diff, now that x11proto-core-dev has
+    a .pc file.  Make the dep on libx11-dev versioned so that we're sure
+    to have an xproto.pc file (from xorg 7.0 or higher).
+
+ -- Andres Salomon <dilinger@debian.org>  Sun, 23 Jul 2006 03:17:32 -0400
+
+xft (2.1.8.2-8) unstable; urgency=low
+
+  * Bump standards version to 3.7.2.0
+  * Bump debhelper compat level to 5
+  * Rebuild with freetype6 2.2.1, which fixes ABI breakages of the past.
+    Thanks Steve Langasek and Keith Packard for managing the freetype side of
+    things. (closes: #350113)
+
+ -- David Nusinow <dnusinow@debian.org>  Sun, 21 May 2006 16:18:09 -0400
+
+xft (2.1.8.2-7) unstable; urgency=low
+
+  * Reorder makeshlib command in rules file so that ldconfig is run
+    properly. Thanks Drew Parsons and Steve Langasek. (closes: #363922)
+  * Run dh_install with --list-missing
+  * Fix package name in rules file so that the debugging symbols go to the
+    right place. Thanks Tim Johann. (closes: #365341)
+  * Remove useless instaces of x-dev in dependencies. Thaks Ross Burton.
+    (closes: #363507)
+
+ -- David Nusinow <dnusinow@debian.org>  Tue,  2 May 2006 22:31:46 -0400
+
+xft (2.1.8.2-6) unstable; urgency=low
+
+  * Upload to unstable
+  * Move the header files back to /usr/include/X11/Xft to bring them in line
+    with X11R7
+  * Add versioned pre-depends on x11-common to match X11R7. Do this for all
+    packages shipped by this source package.
+
+ -- David Nusinow <dnusinow@debian.org>  Thu, 23 Mar 2006 22:44:40 -0500
+
+xft (2.1.8.2-5) unstable; urgency=low
+
+  * Actually install the header files to /usr/X11R6/include/Xft. Thanks Steve
+    Langasek.
+
+ -- David Nusinow <dnusinow@debian.org>  Wed, 22 Mar 2006 00:33:46 -0500
+
+xft (2.1.8.2-4) unstable; urgency=low
+
+  * Make libxft-dev pre-depend on x11-common so as to make sure that the
+    symlink for /usr/include/X11 is already in place when we install the
+    package. (closes: #358254, #358260, #350298, #358308)
+
+ -- David Nusinow <dnusinow@debian.org>  Wed, 22 Mar 2006 00:06:39 -0500
+
+
+xft (2.1.8.2-3) unstable; urgency=low
+
+  * Include freetype headers in cflags in the xft.pc file. This is an edit to
+    001_no_export_freetype.diff. The freetype headers are included in xft's
+    headers, so these are necessary. Also, don't use variables in the .pc file
+    that haven't been defined anywhere. Thanks to Roger Leigh, Decklin Foster,
+    Eric Dorland, and Steve Langasek (who wrote the patch). (closes: #350458)
+
+ -- David Nusinow <dnusinow@debian.org>  Sun,  5 Feb 2006 12:59:29 -0500
+
+xft (2.1.8.2-2) unstable; urgency=low
+
+  * Add 002_no_xproto_dep.diff so that the .pc file doesn't depend on xproto,
+    which doesn't yet have a .pc file in Debian (to be removed when 7.0 enters
+    the archive). Thanks Mike Hommey. (closes: #349678)
+  * Include patch from Steve Langasek in full from previous upload. This
+    should work around the issue properly. (closes: #349318)
+
+ -- David Nusinow <dnusinow@debian.org>  Tue, 24 Jan 2006 21:52:01 -0500
+
+xft (2.1.8.2-1) unstable; urgency=low
+
+  * Add build-dep on quilt
+  * Add 001_no_export_freetype.diff. This is a modified patch from Steve
+    Langasek that causes xft.pc not to export freetype or xrender as part of
+    the interface, but hide them in Requires.private instead (closes: #349318)
+  * Remove versioned build-deps on libx11 and libxrender.
+  * Move preinst to preinst.in so it doesn't get deleted by clean target. We
+    really need a better way to deal with these things...
+
+ -- David Nusinow <dnusinow@debian.org>  Sun, 22 Jan 2006 22:35:36 -0500
+
+libxft (2.1.8.2-0ubuntu2) dapper; urgency=low
+
+  * Change dependency on x-common to x11-common.
+
+ -- Daniel Stone <daniel.stone@ubuntu.com>  Thu, 19 Jan 2006 18:27:58 +1100
+
+libxft (2.1.8.2-0ubuntu1) dapper; urgency=low
+
+  * New upstream release.
+  * Repackaged to fit all the other X packages.
+  * Stop shipping libXft.la.
+
+ -- Daniel Stone <daniel.stone@ubuntu.com>  Wed, 21 Dec 2005 13:13:31 +1100
+
+xft (2.1.8.1-0ubuntu1) dapper; urgency=low
+
+  * New upstream release.
+
+ -- Daniel Stone <daniel.stone@ubuntu.com>  Mon, 12 Dec 2005 15:33:13 +1100
+
+xft (2.1.7-1ubuntu2) breezy; urgency=low
+
+  * Add Pre-Depends on x-common to libxft-dev, so its files don't get caught
+    in /usr/X11R6 thanks to symlink treachery.
+
+ -- Daniel Stone <daniel.stone@ubuntu.com>  Thu, 19 May 2005 00:48:57 +1000
+
+xft (2.1.7-1ubuntu1) breezy; urgency=low
+
+  * Move files from /usr/X11R6 to /usr.
+
+ -- Fabio M. Di Nitto <fabbione@ubuntu.com>  Tue, 17 May 2005 18:44:50 +0200
+
+xft (2.1.7-1) unstable; urgency=low
+
+  * New upstream release.
+    + Keith Packard attests, and Branden Robinson verified as far as he is
+      able, that no interface changes have been made since 2.1.2.
+    + Highlights of upstream changes:
+      - Change FC_CHARCELL and FC_MONO interpretation.  FC_MONO no longer
+        clips glyphs to charcell, you must specify FC_CHARCELL for that.
+      - Add support for FT_GlyphSlot_Embolden where it exists (which it
+        usually doesn't).
+      - Avoid crashing when using FT_Face objects.
+      - Deal with broken FreeType 2.1.7 BDF/PCF loaders by trying both
+        y_ppem/x_ppem and width/height values.
+      - Work with older versions of Fontconfig by using various pattern
+        elements only when defined.
+      - Change Freetype includes to new syntax.
+      - Search for nearest bitmap for bitmap-only fonts.
+      - Support fontconfig 2.2 release which doesn't include FC_HINT_STYLE.
+
+  * Update Debian copyright file with URL to new tar archive, and identify
+    Keith Packard as the upstream maintainer, not the upstream author
+    (upstream now provides an AUTHORS file to clarify the latter).
+
+  * Correct and enhance xft-config's usage message:
+    + No non-option arguments are allowed.
+    + At least one option argument must be specified.
+    + Use ellipsis notation to indicate that more than one option is allowed.
+    + Provide one-sentence summary of the command's purpose.
+    + Sort option names in lexicographic order.
+
+  * Write and ship manual page for xft-config.
+
+  * Drop libxft2.docs debhelper file; CDBS is now brainy enough to identify
+    and tell dh_installdocs to ship a non-empty README file, so libxft2.docs
+    has become redundant.
+
+  * Add debian/compat file to declare debhelper version 4 compatibility.
+
+ -- Branden Robinson <branden@debian.org>  Fri,  1 Apr 2005 13:13:48 -0500
+
+xft (2.1.2-6) unstable; urgency=low
+
+  * Make package compatible with the XFree86 4.3.0 package reorganization.
+    - debian/control:
+      + package build-depends on x-dev and libx11-dev instead of xlibs-dev
+      + libxrender-dev depends on x-dev and libx11-dev instead of xlibs-dev
+      + make libxft-dev conflict with xlibs-dev (<< 4.3.0) due to (now
+        undiverted) file overlaps
+    - debian/libxft-dev.preinst: remove diversions made by previous versions
+      of package if present
+    - debian/libxft-dev.postrm: deleted
+
+ -- Branden Robinson <branden@debian.org>  Thu, 11 Mar 2004 02:13:15 -0500
+
+xft (2.1.2-5) unstable; urgency=medium
+
+  * Urgency due to fix for FTBFS problem introduced by new FreeType library.
+
+  * Clean up package's build-dependencies and dependencies.
+    - debian/control:
+      + Drop versioning of build-dependencies on libxrender-dev and xlibs-dev.
+        All officially released versions of these Debian packages are
+        sufficient to build this package.
+      + Drop package dependencies on debhelper's "${misc:Depends}" construct;
+        this package is too simple to need it.
+      + Drop versioning of libxft-dev's dependencies on libxrender-dev and
+        xlibs-dev.  All officially released versions of these Debian packages
+        should be sufficient to objects using this package.
+      + Drop libxft-dev's dependency on pkg-config; pkg-config is supported
+        but not mandated.
+
+  * Document more functions in the Xft(3) manual page.
+    - Xft.3.in
+
+  * Set package maintainer to the Debian X Strike Force and put myself in the
+    Uploaders field.
+    - debian/control
+
+  * Do not include <freetype/freetype.h> directly; use the macro FT_FREETYPE_H
+    to include it instead, as required by freetype 2.1.7 (fixes FTBFS when
+    FreeType 2.1.7 is on the system; thanks, Tore Anderson).
+    (Closes: #221129)
+    - Xft.h
+
+  * Stop passing --x-includes and --x-libraries flags to
+    DEB_CONFIGURE_EXTRA_FLAGS; AC_PATH_X suffices to locate the X include
+    files and libraries.
+    - debian/rules
+
+  * Pass --disable-rpath flag to DEB_CONFIGURE_EXTRA_FLAGS; consequently, drop
+    invocation of chrpath from common-install-arch target.
+    - debian/rules
+    - debian/control: drop build-dependency on chrpath
+
+  * In the pre-installation script, only remove diversions from old
+    libxft2-dev package if that package has those diversions; dpkg-divert will
+    barf if you try to remove a nonexistent diversion when a different package
+    is diverting the same file.  This enables libxft-dev to be upgraded from
+    the previous version, and installed over the same version.
+    - debian/libxft-dev.preinst
+
+ -- Branden Robinson <branden@debian.org>  Mon, 17 Nov 2003 03:07:41 -0500
+
+xft (2.1.2-4) unstable; urgency=low
+
+  * Set AM_MAINTAINER_MODE because we do not want users of the Debian source
+    package to have to have automake installed.
+    - configure.ac
+
+  * Run aclocal && automake --foreign && autoconf to resynchronize with
+    changes to Makefile.am and configure.ac.
+    - Makefile.in
+    - aclocal.m4
+    - configure
+
+  * Make libxft-dev conflict with and provide libxft2-dev to help apt figure
+    out an upgrade path.  Deliberately *not* making libxft-dev replace
+    libxft2-dev, even though it would be correct to do so, because doing that
+    plays such havoc with dpkg-divert that libxft-dev will fail to install on
+    upgrades from libxft2-dev.  This way libxft2-dev will be properly removed
+    first.
+    - debian/control
+
+ -- Branden Robinson <branden@debian.org>  Wed,  8 Oct 2003 18:09:37 -0500
+
+xft (2.1.2-3) unstable; urgency=low
+
+  * Migrate dpkg diversions from libxft2-dev to libxft-dev, which was
+    neglected in the previous release.
+    - debian/libxft-dev.preinst:
+      + remove all previous diversions created by libxft2-dev on all installs
+        and upgrades (libxft-dev's preinst script will not be passed a $2
+        corresponding to the most-recently-configured version of libxft2-dev)
+      + add diversions using new package name
+    - debian/libxft-dev.postrm: remove diversions using new package name
+
+ -- Branden Robinson <branden@debian.org>  Tue,  7 Oct 2003 15:02:06 -0500
+
+xft (2.1.2-2) unstable; urgency=low
+
+  * Take a hatchet to the RPATH that libtool insists on putting into the
+    libXft shared object by using chrpath.
+    - debian/control: add build-dependency on chrpath
+    - debian/rules: add common-install-arch double-colon rule to invoke
+      chrpath on the libXft shared object
+
+ -- Branden Robinson <branden@debian.org>  Tue,  7 Oct 2003 00:00:13 -0500
+
+xft (2.1.2-1) unstable; urgency=low
+
+  * new upstream version
+    - debian/copyright:
+      + updated URL of upstream release
+      + resync copyright and license notice with upstream
+
+  * Rename source package to "xft" from "xft2".
+    - debian/control
+
+  * Rename libxft2-dev package to libxft-dev.  Consequently, drop conflict and
+    provide relationship with (formerly virtual) libxft-dev package.
+    - debian/control
+    - debian/libxft-dev.install: renamed from libxft2-dev.install
+    - debian/libxft-dev.postrm: renamed from libxft2-dev.postrm
+    - debian/libxft-dev.preinst: renamed from libxft2-dev.preinst
+
+  * Add versioning (>> 4.2.1) to libxft-dev's dependency on xlibs-dev.
+    - debian/control
+
+  * Ship upstream README in libxft2's documentation directory.
+    - debian/libxft2.docs
+
+  * Correct libxft2-dbg's extended description to mention the correct path
+    where the debugging library is installed.
+    - debian/control
+
+  * Migrate from CBS to CDBS.
+    - debian/control: add build-dependency on cdbs (>= 0.4.12) (thanks to
+      Colin Walters for adding debugging package support I can use with a
+      clear conscience :) )
+    - debian/rules: renamed from debian/rocks and translated to CDBS-speak
+
+ -- Branden Robinson <branden@debian.org>  Mon,  6 Oct 2003 20:55:54 -0500
+
+xft2 (2.1.1-3) unstable; urgency=low
+
+  * configure: re-run autoconf to expose the fix to configure.ac from 2.1.1-1
+    (thanks, Robert Millan) (Closes: #185536)
+
+  * debian/control:
+    - tweak packages' short descriptions
+    - make libxft2 depend on ${misc:Depends} so debhelper can do its thing
+    - add libxft2-dbg binary package
+  * debian/rocks:
+    - new rule, deb-makeshlibs-libxft2-dbg, which is a no-op to prevent CBS
+      from running dh_makeshlibs on this package
+    - new rule, deb-strip-libxft2-dbg, which is a no-op to prevent CBS from
+      running dh_strip on this package
+  * debian/libxft2-dbg.install: ship the shared object(s) in
+    /usr/X11R6/lib/debug/
+
+  * Version the build dependency on xlibs-dev to specify version 4.2.1 or
+    later; xft2 will not build successfully with woody-era (4.1.0) versions of
+    xlibs-dev.
+    - debian/control
+
+  * Bump Standards-Version to 3.6.1; no changes necessary.
+    - debian/control
+
+  * Source package build-depends, and libxft2-dev depends, on libxrender-dev
+    (>> 0.8.1).
+    - debian/control
+
+  * Drop README.Debian file; xft will be separately packaged from XFree86 for
+    the forseeable future.
+    - debian/README.Debian: deleted
+
+  * Ship libXft.la file in libxft2-dev.
+    - debian/libxft2-dev.install
+
+  * Ship library files in /usr/lib instead of /usr/X11R6/lib, and debugging
+    library files in /usr/lib/debug instead of /usr/X11R6/lib/debug, per
+    policy 11.8.7.  Continuing to ship include files in /usr/X11R6/include/X11
+    until upstream default changes.
+    - debian/libxft2{,-dbg,-dev}.install
+
+  * Ship Xft.3 manpage (in /usr/share/man/man3, so it does not conflict with
+    the XFree86-provided Xft manpage, which is being renamed to Xft1.3x in
+    4.3.0 anyway).
+    - debian/libxft2-dev.install
+
+ -- Branden Robinson <branden@debian.org>  Sat,  4 Oct 2003 19:31:11 -0500
+
+xft2 (2.1.1-2) unstable; urgency=low
+
+  * debian/control: move libxft2-dev from section "devel" to "libdevel"
+  * debian/rocks:
+    - drop deb-common-build and deb-extra-clean rules per Colin Walters
+    - pass --x-includes and --x-libraries to configure script, since the
+      AC_PATH_X autoconf macro is highly suboptimal
+    - don't be so crazy about the versioning in the shlibs file (i.e., drop
+      Debian package component)
+  * debian/libxft2-dev.preinst: sense of the version comparison when removing
+    the obsolete diversion of XftFreetype.h was wrong; fixed
+
+ -- Branden Robinson <branden@debian.org>  Wed, 30 Apr 2003 23:24:33 -0500
+
+xft2 (2.1.1-1) unstable; urgency=low
+
+  * New upstream version.
+    + includes fixes for some bugs when drawing to non-RENDER-enabled servers
+      (Closes: #178817)
+    + handle both 0-indexed and 1-indexed glyph numbering schemes
+      (Closes: #190610)
+    + xft-config --cflags and --libs now give more correct output
+      (Closes: #179942, #179944)
+
+  * configure.ac: add -lXext and -lX11 to XRENDER_LIBS
+  * xft-config.in: add -lX11 to --libs output
+  * xft.pc.in: add -lX11 to Libs line
+
+  * the above changes ensure that libXft.so.2.1.1 has proper linkage, declares
+    needed shared objects correctly, and thus enables dpkg-shlibdeps to find
+    what it's looking for (Closes: #186042)
+
+  * debian/*: various cosmetic cleanups
+  * debian/control:
+    - Update Build-Depends and libxft-dev's Depends to reflect all development
+      library dependencies
+    - Bump Standards-Version to 3.5.9.
+    - Rewrite extended descriptions.
+  * debian/copyright: updated
+  * debian/rocks: stop nuking config.{guess,sub} in debian-extra-clean rule;
+    it is no longer part of the upstream source archive
+  * debian/libxft2-dev.{postrm,preinst}: stop diverting XftFreetype.h, since
+    the package no longer ships it; also handle removal of now-obsolete
+    diversion when upgrading from earlier versions
+
+ -- Branden Robinson <branden@debian.org>  Wed, 30 Apr 2003 01:31:58 -0500
+
+xft2 (2.1-8) unstable; urgency=low
+
+  * Adopting this package per request from Colin Walters (XFree86 4.3.0 will
+    be generating libxft2, anyway.)
+  * config/{config.guess,config.sub,ltmain.sh}: updated with libtoolize
+    --force --copy
+  * debian/control: set Maintainer field to me
+
+ -- Branden Robinson <branden@debian.org>  Tue, 11 Mar 2003 23:28:33 -0500
+
+xft2 (2.1-7) unstable; urgency=low
+
+  * debian/control:
+    - Build-Depend on xlibs-dev (>= 4.2.0) (Closes: #174596).
+    - [libxft2-dev] Depend on xlibs-dev (>= 4.2.0).
+
+ -- Colin Walters <walters@debian.org>  Fri, 17 Jan 2003 13:11:34 -0500
+
+xft2 (2.1-6) unstable; urgency=low
+
+  * debian/rules:
+    - Update to latest version of Colin's Build System.
+  * debian/rocks:
+    - Tighten up shlibs for libxft2.
+
+ -- Colin Walters <walters@debian.org>  Wed,  8 Jan 2003 22:47:30 -0500
+
+xft2 (2.1-5) unstable; urgency=low
+
+  * debian/control:
+    - Build-Depend on the latest libfontconfig1-dev, and by transitivity
+    the latest libfreetype6-dev.  The libfreetype6-dev issue was causing
+    configuration problems, which is what caused the autoconf macros to
+    pick up empty paths for X. (Closes: #172661).
+
+ -- Colin Walters <walters@debian.org>  Sun, 22 Dec 2002 17:42:30 -0500
+
+xft2 (2.1-4) unstable; urgency=low
+
+  * debian/patches/fix-configure-in-x-paths.patch:
+    - New patch (Closes: #172703, #172661).
+  * debian/rocks:
+    - Remove extra cruft in deb-extra-clean rule.
+
+ -- Colin Walters <walters@debian.org>  Thu, 12 Dec 2002 17:42:57 -0500
+
+xft2 (2.1-3) unstable; urgency=low
+
+  * debian/control:
+    - Depend (and Build-Depend) on the latest libfontconfig1-dev.
+  * debian/rules:
+    - Update to latest version of Colin's Build System.
+
+ -- Colin Walters <walters@debian.org>  Wed, 11 Dec 2002 00:42:03 -0500
+
+xft2 (2.1-2) unstable; urgency=low
+
+  * First upload to unstable; this is part of #170559, which is closed
+    with the fontconfig upload.
+  * debian/rules:
+    - Update to latest version of Colin's Build System.
+
+ -- Colin Walters <walters@debian.org>  Fri,  6 Dec 2002 01:39:21 -0500
+
+xft2 (2.1-1) unstable; urgency=low
+
+  * New upstream version.
+  * debian/rules:
+    - Use Colin's Build System.
+  * debian/control:
+    - Bump Standards-Version to 3.5.8.
+    - Build-Depend on the latest fontconfig.
+  * debian/libxft2-dev.{preinst,postrm}:
+    - Add Debhelper tokens.
+  * debian/copyright:
+    - Fix Upstream Authors.
+
+ -- Colin Walters <walters@debian.org>  Tue,  3 Dec 2002 23:04:12 -0500
+
+xft2 (2.0-4) unstable; urgency=low
+
+  * debian/libxft2.install:
+    - Install xft-config.
+
+ -- Colin Walters <walters@debian.org>  Sat, 19 Oct 2002 10:24:35 -0400
+
+xft2 (2.0-3) unstable; urgency=low
+
+  * debian/libxft2.install:
+    - Install libraries in /usr/X11R6/lib, not /usr/lib.
+
+ -- Colin Walters <walters@debian.org>  Tue, 15 Oct 2002 11:22:58 -0400
+
+xft2 (2.0-2) unstable; urgency=low
+
+  * debian/control:
+    - [xft2] Build-Depend on xlibs-dev, not xlib6g-dev.
+    - [libxft2-dev] Depend on xlibs-dev, not xlib6g-dev.  Also depend on pkg-config.
+  * debian/rules:
+    - Install xft.pc.
+
+ -- Colin Walters <walters@debian.org>  Mon, 14 Oct 2002 22:59:06 -0400
+
+xft2 (2.0-1) unstable; urgency=low
+
+  * Initial version.
+
+ -- Colin Walters <walters@debian.org>  Sun, 13 Oct 2002 14:43:56 -0400
+
+vim:set ai tw=78 et sw=2 sts=2:
diff -Naur libXft-2.1.14.orig/debian/compat libXft-2.1.14/debian/compat
--- libXft-2.1.14.orig/debian/compat	1970-01-01 01:00:00.000000000 +0100
+++ libXft-2.1.14/debian/compat	2010-02-20 14:45:51.000000000 +0100
@@ -0,0 +1 @@
+5
diff -Naur libXft-2.1.14.orig/debian/control libXft-2.1.14/debian/control
--- libXft-2.1.14.orig/debian/control	1970-01-01 01:00:00.000000000 +0100
+++ libXft-2.1.14/debian/control	2010-02-20 14:45:51.000000000 +0100
@@ -0,0 +1,64 @@
+Source: xft
+Section: devel
+Priority: optional
+Maintainer: Ubuntu X-SWAT <ubuntu-x@lists.ubuntu.com>
+XSBC-Original-Maintainer: Debian X Strike Force <debian-x@lists.debian.org>
+Uploaders: David Nusinow <dnusinow@debian.org>, Andres Salomon <dilinger@debian.org>, Julien Cristau <jcristau@debian.org>
+Build-Depends:
+ debhelper (>= 5.0.0),
+ libfontconfig1-dev,
+ libfreetype6-dev,
+ libx11-dev,
+ libxrender-dev,
+ zlib1g-dev | libz-dev,
+ quilt,
+ automake,
+ libtool,
+ xutils-dev (>= 1:7.5~1)
+Standards-Version: 3.8.3
+Vcs-Git: git://git.debian.org/git/pkg-xorg/lib/xft
+Vcs-Browser: http://git.debian.org/?p=pkg-xorg/lib/xft.git
+
+Package: libxft2
+Section: libs
+Architecture: any
+Depends: ${shlibs:Depends}
+Description: FreeType-based font drawing library for X
+ Xft provides a client-side font API for X applications, making the FreeType
+ font rasterizer available to X clients.  Fontconfig is used for font
+ specification resolution.  Where available, the RENDER extension handles
+ glyph drawing; otherwise, the core X protocol is used.
+
+Package: libxft2-dbg
+Section: debug
+Priority: extra
+Architecture: any
+Depends: libxft2 (= ${binary:Version}), ${shlibs:Depends}
+Description: FreeType-based font drawing library for X (unstripped)
+ Xft provides a client-side font API for X applications, making the FreeType
+ font rasterizer available to X clients.  Fontconfig is used for font
+ specification resolution.  Where available, the RENDER extension handles
+ glyph drawing; otherwise, the core X protocol is used.
+ .
+ This package provides an unstripped shared object with debugging symbols,
+ useful to provide a backtrace with symbol names in a debugger; this
+ facilitates interpretation of core dumps, and aids in finding logic errors in
+ programs using this library (or the library itself).  The library is
+ installed in /usr/lib/debug and can be used by placing that directory in the
+ LD_LIBRARY_PATH environment variable when the code to be debugged is
+ executed.  Non-programmers will likely have little use for this package, and
+ should use libxft2 instead.
+
+Package: libxft-dev
+Section: libdevel
+Architecture: any
+Depends: libxft2 (= ${binary:Version}), libc6-dev | libc-dev, libfontconfig1-dev, libfreetype6-dev, libx11-dev (>= 2:1.0.0), libxrender-dev, zlib1g-dev | libz-dev
+Conflicts: libxft2-dev, xlibs-dev (<< 4.3.0)
+Provides: libxft2-dev
+Description: FreeType-based font drawing library for X (development files)
+ Xft provides a client-side font API for X applications, making the FreeType
+ font rasterizer available to X clients.  Fontconfig is used for font
+ specification resolution.  Where available, the RENDER extension handles
+ glyph drawing; otherwise, the core X protocol is used.
+ .
+ This package provides a static library and C header files.
diff -Naur libXft-2.1.14.orig/debian/copyright libXft-2.1.14/debian/copyright
--- libXft-2.1.14.orig/debian/copyright	1970-01-01 01:00:00.000000000 +0100
+++ libXft-2.1.14/debian/copyright	2010-02-20 14:45:51.000000000 +0100
@@ -0,0 +1,33 @@
+This package was downloaded from
+http://xorg.freedesktop.org/releases/individual/lib/
+
+This package was originally Debianized by Colin Walters
+<walters@debian.org> on Sun, 13 Oct 2002 15:01:50 -0400.
+
+Later versions were Debianized by Branden Robinson <branden@debian.org>.
+
+Upstream maintainer: Keith Packard
+
+Copyright and license:
+
+Copyright © 2001,2003 Keith Packard
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation, and that the name of Keith Packard not be used in
+advertising or publicity pertaining to distribution of the software without
+specific, written prior permission.  Keith Packard makes no
+representations about the suitability of this software for any purpose.  It
+is provided "as is" without express or implied warranty.
+
+KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+PERFORMANCE OF THIS SOFTWARE.
+
+$Id: copyright 114 2005-03-30 07:39:46Z branden $
diff -Naur libXft-2.1.14.orig/debian/libxft2.install libXft-2.1.14/debian/libxft2.install
--- libXft-2.1.14.orig/debian/libxft2.install	1970-01-01 01:00:00.000000000 +0100
+++ libXft-2.1.14/debian/libxft2.install	2010-02-20 14:45:51.000000000 +0100
@@ -0,0 +1 @@
+usr/lib/libXft.so.*
diff -Naur libXft-2.1.14.orig/debian/libxft-dev.install libXft-2.1.14/debian/libxft-dev.install
--- libXft-2.1.14.orig/debian/libxft-dev.install	1970-01-01 01:00:00.000000000 +0100
+++ libXft-2.1.14/debian/libxft-dev.install	2010-02-20 14:45:51.000000000 +0100
@@ -0,0 +1,7 @@
+usr/include/X11/Xft/*
+usr/lib/libXft.a
+usr/lib/libXft.so
+usr/lib/pkgconfig/*.pc
+usr/bin/xft-config
+usr/share/man/man1/*
+usr/share/man/man3/*
diff -Naur libXft-2.1.14.orig/debian/patches/001_no_export_freetype.diff libXft-2.1.14/debian/patches/001_no_export_freetype.diff
--- libXft-2.1.14.orig/debian/patches/001_no_export_freetype.diff	1970-01-01 01:00:00.000000000 +0100
+++ libXft-2.1.14/debian/patches/001_no_export_freetype.diff	2010-02-20 14:45:51.000000000 +0100
@@ -0,0 +1,13 @@
+Index: xft/xft.pc.in
+===================================================================
+--- xft.orig/xft.pc.in
++++ xft/xft.pc.in
+@@ -6,7 +6,7 @@
+ Name: Xft
+ Description: X FreeType library
+ Version: @VERSION@
+-Requires: xproto, xrender, fontconfig, freetype2
++Requires: xproto
+ Requires.private: xrender, fontconfig, freetype2
+ Cflags: -I${includedir}
+ Libs: -L${libdir} -lXft
diff -Naur libXft-2.1.14.orig/debian/patches/100-libXft-2.1.10-lcd-filter-3.patch libXft-2.1.14/debian/patches/100-libXft-2.1.10-lcd-filter-3.patch
--- libXft-2.1.14.orig/debian/patches/100-libXft-2.1.10-lcd-filter-3.patch	1970-01-01 01:00:00.000000000 +0100
+++ libXft-2.1.14/debian/patches/100-libXft-2.1.10-lcd-filter-3.patch	2010-02-20 14:45:51.000000000 +0100
@@ -0,0 +1,851 @@
+Index: xft/src/xftdpy.c
+===================================================================
+--- xft.orig/src/xftdpy.c	2009-12-04 15:42:00.000000000 +0200
++++ xft/src/xftdpy.c	2009-12-04 15:47:57.000000000 +0200
+@@ -369,6 +369,10 @@
+ 	goto bail1;
+     if (!_XftDefaultInitInteger (dpy, pat, FC_RGBA))
+ 	goto bail1;
++#ifdef FC_LCD_FILTER
++    if (!_XftDefaultInitInteger (dpy, pat, FC_LCD_FILTER))
++	goto bail1;
++#endif
+     if (!_XftDefaultInitBool (dpy, pat, FC_ANTIALIAS))
+ 	goto bail1;
+ #ifdef FC_EMBOLDEN
+@@ -521,6 +525,14 @@
+ 			      XftDefaultGetInteger (dpy, FC_RGBA, screen, 
+ 						    subpixel));
+     }
++#ifdef FC_LCD_FILTER
++    if (FcPatternGet (pattern, FC_LCD_FILTER, 0, &v) == FcResultNoMatch)
++    {
++	FcPatternAddInteger (pattern, FC_LCD_FILTER,
++			     XftDefaultGetInteger (dpy, FC_LCD_FILTER, screen,
++						   FC_LCD_DEFAULT));
++    }
++#endif
+     if (FcPatternGet (pattern, FC_MINSPACE, 0, &v) == FcResultNoMatch)
+     {
+ 	FcPatternAddBool (pattern, FC_MINSPACE,
+Index: xft/src/xftfreetype.c
+===================================================================
+--- xft.orig/src/xftfreetype.c	2009-12-04 15:42:00.000000000 +0200
++++ xft/src/xftfreetype.c	2009-12-04 15:47:57.000000000 +0200
+@@ -469,6 +469,21 @@
+ 	goto bail1;
+     }
+     
++#ifdef FC_LCD_FILTER 
++    /*
++     * Get lcd_filter value
++     */
++    switch (FcPatternGetInteger (pattern, FC_LCD_FILTER, 0, &fi->lcd_filter)) {
++    case FcResultNoMatch:
++	fi->lcd_filter = FC_LCD_DEFAULT;
++	break;
++    case FcResultMatch:
++	break;
++    default:
++	goto bail1;
++    }
++#endif
++    
+     /*
+      * Get matrix and transform values
+      */
+Index: xft/src/xftglyphs.c
+===================================================================
+--- xft.orig/src/xftglyphs.c	2009-12-04 15:42:00.000000000 +0200
++++ xft/src/xftglyphs.c	2009-12-04 15:59:38.000000000 +0200
+@@ -21,27 +21,18 @@
+  */
+ 
+ #include "xftint.h"
+-#include <freetype/ftoutln.h>
+ 
+ #if HAVE_FT_GLYPHSLOT_EMBOLDEN
+ #include <freetype/ftsynth.h>
+ #endif
+ 
+-static const int    filters[3][3] = {
+-    /* red */
+-#if 0
+-{    65538*4/7,65538*2/7,65538*1/7 },
+-    /* green */
+-{    65536*1/4, 65536*2/4, 65537*1/4 },
+-    /* blue */
+-{    65538*1/7,65538*2/7,65538*4/7 },
++#if FREETYPE_MAJOR*10000 + FREETYPE_MINOR*100 + FREETYPE_PATCH < 20202
++#  error  "FreeType 2.2.2 or later required to compile this version of libXft"
+ #endif
+-{    65538*9/13,65538*3/13,65538*1/13 },
+-    /* green */
+-{    65538*1/6, 65538*4/6, 65538*1/6 },
+-    /* blue */
+-{    65538*1/13,65538*3/13,65538*9/13 },
+-};
++
++#include FT_OUTLINE_H
++#include FT_LCD_FILTER_H
++#include FT_SYNTHESIS_H
+ 
+ /*
+  * Validate the memory info for a font
+@@ -69,6 +60,295 @@
+ 		font->glyph_memory, glyph_memory);
+ }
+ 
++
++/* we sometimes need to convert the glyph bitmap in a FT_GlyphSlot
++ * into a different format. For example, we want to convert a
++ * FT_PIXEL_MODE_LCD or FT_PIXEL_MODE_LCD_V bitmap into a 32-bit
++ * ARGB or ABGR bitmap.
++ *
++ * this function prepares a target descriptor for this operation.
++ *
++ * input :: target bitmap descriptor. The function will set its
++ *          'width', 'rows' and 'pitch' fields, and only these
++ *
++ * slot  :: the glyph slot containing the source bitmap. this
++ *          function assumes that slot->format == FT_GLYPH_FORMAT_BITMAP
++ *
++ * mode  :: the requested final rendering mode. supported values are
++ *          MONO, NORMAL (i.e. gray), LCD and LCD_V
++ *
++ * the function returns the size in bytes of the corresponding buffer,
++ * it's up to the caller to allocate the corresponding memory block
++ * before calling _fill_xrender_bitmap
++ *
++ * it also returns -1 in case of error (e.g. incompatible arguments,
++ * like trying to convert a gray bitmap into a monochrome one)
++ */
++static int
++_compute_xrender_bitmap_size( FT_Bitmap*      target,
++                              FT_GlyphSlot    slot,
++                              FT_Render_Mode  mode )
++{
++    FT_Bitmap*  ftbit;
++    int         width, height, pitch;
++
++    if ( slot->format != FT_GLYPH_FORMAT_BITMAP )
++        return -1;
++
++    // compute the size of the final bitmap
++    ftbit  = &slot->bitmap;
++
++    width  = ftbit->width;
++    height = ftbit->rows;
++    pitch  = (width+3) & ~3;
++
++    switch ( ftbit->pixel_mode )
++    {
++    case FT_PIXEL_MODE_MONO:
++        if ( mode == FT_RENDER_MODE_MONO )
++        {
++            pitch = (((width+31) & ~31) >> 3);
++            break;
++        }
++        /* fall-through */
++
++    case FT_PIXEL_MODE_GRAY:
++        if ( mode == FT_RENDER_MODE_LCD   ||
++             mode == FT_RENDER_MODE_LCD_V )
++        {
++          /* each pixel is replicated into a 32-bit ARGB value */
++          pitch = width*4;
++        }
++        break;
++
++    case FT_PIXEL_MODE_LCD:
++        if ( mode != FT_RENDER_MODE_LCD )
++            return -1;
++
++        /* horz pixel triplets are packed into 32-bit ARGB values */
++        width   /= 3;
++        pitch    = width*4;
++        break;
++
++    case FT_PIXEL_MODE_LCD_V:
++        if ( mode != FT_RENDER_MODE_LCD_V )
++            return -1;
++
++        /* vert pixel triplets are packed into 32-bit ARGB values */
++        height  /= 3;
++        pitch    = width*4;
++        break;
++
++    default:  /* unsupported source format */
++        return -1;
++    }
++
++    target->width  = width;
++    target->rows   = height;
++    target->pitch  = pitch;
++    target->buffer = NULL;
++
++    return pitch * height;
++}
++
++/* this functions converts the glyph bitmap found in a FT_GlyphSlot
++ * into a different format (see _compute_xrender_bitmap_size)
++ *
++ * you should call this function after _compute_xrender_bitmap_size
++ *
++ * target :: target bitmap descriptor. Note that its 'buffer' pointer
++ *           must point to memory allocated by the caller
++ *
++ * slot   :: the glyph slot containing the source bitmap
++ *
++ * mode   :: the requested final rendering mode
++ *
++ * bgr    :: boolean, set if BGR or VBGR pixel ordering is needed
++ */
++static void
++_fill_xrender_bitmap( FT_Bitmap*      target,
++                      FT_GlyphSlot    slot,
++                      FT_Render_Mode  mode,
++                      int             bgr )
++{
++    FT_Bitmap*   ftbit = &slot->bitmap;
++
++    {
++        unsigned char*   srcLine   = ftbit->buffer;
++        unsigned char*   dstLine   = target->buffer;
++        int              src_pitch = ftbit->pitch;
++        int              width     = target->width;
++        int              height    = target->rows;
++        int              pitch     = target->pitch;
++        int              subpixel;
++        int              h;
++
++        subpixel = ( mode == FT_RENDER_MODE_LCD ||
++                     mode == FT_RENDER_MODE_LCD_V );
++
++        if ( src_pitch < 0 )
++          srcLine -= src_pitch*(ftbit->rows-1);
++
++        switch ( ftbit->pixel_mode )
++        {
++        case FT_PIXEL_MODE_MONO:
++            if ( subpixel )  /* convert mono to ARGB32 values */
++            {
++                for ( h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch )
++                {
++                    int  x;
++
++                    for ( x = 0; x < width; x++ )
++                    {
++                        if ( srcLine[(x >> 3)] & (0x80 >> (x & 7)) )
++                            ((unsigned int*)dstLine)[x] = 0xffffffffU;
++                    }
++                }
++            }
++            else if ( mode == FT_RENDER_MODE_NORMAL )  /* convert mono to 8-bit gray */
++            {
++                for ( h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch )
++                {
++                    int  x;
++
++                    for ( x = 0; x < width; x++ )
++                    {
++                        if ( srcLine[(x >> 3)] & (0x80 >> (x & 7)) )
++                            dstLine[x] = 0xff;
++                    }
++                }
++            }
++            else  /* copy mono to mono */
++            {
++                int  bytes = (width+7) >> 3;
++
++                for ( h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch )
++                    memcpy( dstLine, srcLine, bytes );
++            }
++            break;
++
++        case FT_PIXEL_MODE_GRAY:
++            if ( subpixel )  /* convert gray to ARGB32 values */
++            {
++                for ( h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch )
++                {
++                    int            x;
++                    unsigned int*  dst = (unsigned int*)dstLine;
++
++                    for ( x = 0; x < width; x++ )
++                    {
++                        unsigned int  pix = srcLine[x];
++
++                        pix |= (pix << 8);
++                        pix |= (pix << 16);
++
++                        dst[x] = pix;
++                    }
++                }
++            }
++            else  /* copy gray into gray */
++            {
++                for ( h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch )
++                    memcpy( dstLine, srcLine, width );
++            }
++            break;
++
++        case FT_PIXEL_MODE_LCD:
++            if ( !bgr )
++            {
++                /* convert horizontal RGB into ARGB32 */
++                for ( h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch )
++                {
++                    int            x;
++                    unsigned char* src = srcLine;
++                    unsigned int*  dst = (unsigned int*)dstLine;
++
++                    for ( x = 0; x < width; x++, src += 3 )
++                    {
++                        unsigned int  pix;
++
++                        pix = ((unsigned int)src[0] << 16) |
++                              ((unsigned int)src[1] <<  8) |
++                              ((unsigned int)src[2]      ) |
++                              ((unsigned int)src[1] << 24) ;
++
++                        dst[x] = pix;
++                    }
++                }
++            }
++            else
++            {
++                /* convert horizontal BGR into ARGB32 */
++                for ( h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch )
++                {
++                    int            x;
++                    unsigned char* src = srcLine;
++                    unsigned int*  dst = (unsigned int*)dstLine;
++
++                    for ( x = 0; x < width; x++, src += 3 )
++                    {
++                        unsigned int  pix;
++
++                        pix = ((unsigned int)src[2] << 16) |
++                              ((unsigned int)src[1] <<  8) |
++                              ((unsigned int)src[0]      ) |
++                              ((unsigned int)src[1] << 24) ;
++
++                        dst[x] = pix;
++                    }
++                }
++            }
++            break;
++
++        default:  /* FT_PIXEL_MODE_LCD_V */
++            /* convert vertical RGB into ARGB32 */
++            if ( !bgr )
++            {
++                for ( h = height; h > 0; h--, srcLine += 3*src_pitch, dstLine += pitch )
++                {
++                    int            x;
++                    unsigned char* src = srcLine;
++                    unsigned int*  dst = (unsigned int*)dstLine;
++
++                    for ( x = 0; x < width; x++, src += 1 )
++                    {
++                        unsigned int  pix;
++
++                        pix = ((unsigned int)src[0]           << 16) |
++                              ((unsigned int)src[src_pitch]   <<  8) |
++                              ((unsigned int)src[src_pitch*2]      ) |
++                              ((unsigned int)src[src_pitch]   << 24) ;
++
++                        dst[x] = pix;
++                    }
++                }
++            }
++            else
++            {
++                for ( h = height; h > 0; h--, srcLine += 3*src_pitch, dstLine += pitch )
++                {
++                    int            x;
++                    unsigned char* src = srcLine;
++                    unsigned int*  dst = (unsigned int*)dstLine;
++
++                    for ( x = 0; x < width; x++, src += 1 )
++                    {
++                        unsigned int  pix;
++
++                        pix = ((unsigned int)src[src_pitch*2] << 16) |
++                              ((unsigned int)src[src_pitch]   <<  8) |
++                              ((unsigned int)src[0]                ) |
++                              ((unsigned int)src[src_pitch]   << 24) ;
++
++                        dst[x] = pix;
++                    }
++                }
++            }
++        }
++    }
++}
++
++
+ _X_EXPORT void
+ XftFontLoadGlyphs (Display	    *dpy,
+ 		   XftFont	    *pub,
+@@ -87,20 +367,14 @@
+     unsigned char   *bufBitmap = bufLocal;
+     int		    bufSize = sizeof (bufLocal);
+     int		    size, pitch;
+-    unsigned char   bufLocalRgba[4096];
+-    unsigned char   *bufBitmapRgba = bufLocalRgba;
+-    int		    bufSizeRgba = sizeof (bufLocalRgba);
+-    int		    sizergba, pitchrgba, widthrgba;
+     int		    width;
+     int		    height;
+     int		    left, right, top, bottom;
+-    int		    hmul = 1;
+-    int		    vmul = 1;
+-    FT_Bitmap	    ftbit;
+-    FT_Matrix	    matrix;
++    FT_Bitmap*	    ftbit;
++    FT_Bitmap       local;
+     FT_Vector	    vector;
+-    Bool	    subpixel = False;
+     FT_Face	    face;
++    FT_Render_Mode  mode = FT_RENDER_MODE_MONO;
+ 
+     if (!info)
+ 	return;
+@@ -110,24 +384,19 @@
+     if (!face)
+ 	return;
+ 
+-    matrix.xx = matrix.yy = 0x10000L;
+-    matrix.xy = matrix.yx = 0;
+-
+     if (font->info.antialias)
+     {
+ 	switch (font->info.rgba) {
+ 	case FC_RGBA_RGB:
+ 	case FC_RGBA_BGR:
+-	    matrix.xx *= 3;
+-	    subpixel = True;
+-	    hmul = 3;
++	    mode = FT_RENDER_MODE_LCD;
+ 	    break;
+ 	case FC_RGBA_VRGB:
+ 	case FC_RGBA_VBGR:
+-	    matrix.yy *= 3;
+-	    vmul = 3;
+-	    subpixel = True;
++            mode = FT_RENDER_MODE_LCD_V;
+ 	    break;
++        default:
++            mode = FT_RENDER_MODE_NORMAL;
+ 	}
+     }
+ 
+@@ -148,7 +417,10 @@
+ 	if (xftg->glyph_memory)
+ 	    continue;
+ 	
++        FT_Library_SetLcdFilter( _XftFTlibrary, font->info.lcd_filter);
++
+ 	error = FT_Load_Glyph (face, glyphindex, font->info.load_flags);
++
+ 	if (error)
+ 	{
+ 	    /*
+@@ -181,7 +453,7 @@
+ 	/*
+ 	 * Compute glyph metrics from FreeType information
+ 	 */
+-	if(font->info.transform && glyphslot->format != ft_glyph_format_bitmap) 
++	if(font->info.transform && glyphslot->format != FT_GLYPH_FORMAT_BITMAP)
+ 	{
+ 	    /*
+ 	     * calculate the true width by transforming all four corners.
+@@ -260,17 +532,14 @@
+ 	    }
+ 	}
+ 
+-	if (font->info.antialias)
+-	    pitch = (width * hmul + 3) & ~3;
+-	else
+-	    pitch = ((width + 31) & ~31) >> 3;
+-
+-	size = pitch * height * vmul;
++        if ( glyphslot->format != FT_GLYPH_FORMAT_BITMAP )
++        {
++            error = FT_Render_Glyph( face->glyph, mode );
++            if (error)
++                continue;
++        }
+ 
+-	xftg->metrics.width = width;
+-	xftg->metrics.height = height;
+-	xftg->metrics.x = -TRUNC(left);
+-	xftg->metrics.y = TRUNC(top);
++        FT_Library_SetLcdFilter( _XftFTlibrary, FT_LCD_FILTER_NONE );
+ 
+ 	if (font->info.spacing >= FC_MONO)
+ 	{
+@@ -310,103 +579,13 @@
+ 	    xftg->metrics.yOff = -TRUNC(ROUND(glyphslot->advance.y));
+ 	}
+ 	
+-	/*
+-	 * If the glyph is relatively large (> 1% of server memory),
+-	 * don't send it until necessary
+-	 */
+-	if (!need_bitmaps && size > info->max_glyph_memory / 100)
+-	    continue;
+ 	
+-	/*
+-	 * Make sure there's enough buffer space for the glyph
+-	 */
+-	if (size > bufSize)
+-	{
+-	    if (bufBitmap != bufLocal)
+-		free (bufBitmap);
+-	    bufBitmap = (unsigned char *) malloc (size);
+-	    if (!bufBitmap)
+-		continue;
+-	    bufSize = size;
+-	}
+-	memset (bufBitmap, 0, size);
++        // compute the size of the final bitmap
++        ftbit  = &glyphslot->bitmap;
+ 
+-	/*
+-	 * Rasterize into the local buffer
+-	 */
+-	switch (glyphslot->format) {
+-	case ft_glyph_format_outline:
+-	    ftbit.width      = width * hmul;
+-	    ftbit.rows       = height * vmul;
+-	    ftbit.pitch      = pitch;
+-	    if (font->info.antialias)
+-		ftbit.pixel_mode = ft_pixel_mode_grays;
+-	    else
+-		ftbit.pixel_mode = ft_pixel_mode_mono;
+-	    
+-	    ftbit.buffer     = bufBitmap;
+-	    
+-	    if (subpixel)
+-		FT_Outline_Transform (&glyphslot->outline, &matrix);
+-
+-	    FT_Outline_Translate ( &glyphslot->outline, -left*hmul, -bottom*vmul );
+-
+-	    FT_Outline_Get_Bitmap( _XftFTlibrary, &glyphslot->outline, &ftbit );
+-	    break;
+-	case ft_glyph_format_bitmap:
+-	    if (font->info.antialias)
+-	    {
+-		unsigned char	*srcLine, *dstLine;
+-		int		height;
+-		int		x;
+-		int	    h, v;
+-
+-		srcLine = glyphslot->bitmap.buffer;
+-		dstLine = bufBitmap;
+-		height = glyphslot->bitmap.rows;
+-		while (height--)
+-		{
+-		    for (x = 0; x < glyphslot->bitmap.width; x++)
+-		    {
+-			/* always MSB bitmaps */
+-			unsigned char	a = ((srcLine[x >> 3] & (0x80 >> (x & 7))) ?
+-					     0xff : 0x00);
+-			if (subpixel)
+-			{
+-			    for (v = 0; v < vmul; v++)
+-				for (h = 0; h < hmul; h++)
+-				    dstLine[v * pitch + x*hmul + h] = a;
+-			}
+-			else
+-			    dstLine[x] = a;
+-		    }
+-		    dstLine += pitch * vmul;
+-		    srcLine += glyphslot->bitmap.pitch;
+-		}
+-	    }
+-	    else
+-	    {
+-		unsigned char	*srcLine, *dstLine;
+-		int		h, bytes;
+-
+-		srcLine = glyphslot->bitmap.buffer;
+-		dstLine = bufBitmap;
+-		h = glyphslot->bitmap.rows;
+-		bytes = (glyphslot->bitmap.width + 7) >> 3;
+-		while (h--)
+-		{
+-		    memcpy (dstLine, srcLine, bytes);
+-		    dstLine += pitch;
+-		    srcLine += glyphslot->bitmap.pitch;
+-		}
+-	    }
+-	    break;
+-	default:
+-	    if (XftDebug() & XFT_DBG_GLYPH)
+-		printf ("glyph %d is not in a usable format\n",
+-			(int) glyphindex);
+-	    continue;
+-	}
++        width  = ftbit->width;
++        height = ftbit->rows;
++        pitch  = (width+3) & ~3;
+ 	
+ 	if (XftDebug() & XFT_DBG_GLYPH)
+ 	{
+@@ -423,29 +602,72 @@
+ 		int		x, y;
+ 		unsigned char	*line;
+ 
+-		line = bufBitmap;
+-		for (y = 0; y < height * vmul; y++)
++                line = ftbit->buffer;
++
++                if (ftbit->pitch < 0)
++                  line -= ftbit->pitch*(height-1);
++
++                for (y = 0; y < height; y++)
+ 		{
+ 		    if (font->info.antialias) 
+ 		    {
+-			static char    den[] = { " .:;=+*#" };
+-			for (x = 0; x < pitch; x++)
++                        static const char    den[] = { " .:;=+*#" };
++                        for (x = 0; x < width; x++)
+ 			    printf ("%c", den[line[x] >> 5]);
+ 		    }
+ 		    else
+ 		    {
+-			for (x = 0; x < pitch * 8; x++)
++                        for (x = 0; x < width * 8; x++)
+ 			{
+ 			    printf ("%c", line[x>>3] & (1 << (x & 7)) ? '#' : ' ');
+ 			}
+ 		    }
+ 		    printf ("|\n");
+-		    line += pitch;
++                    line += ftbit->pitch;
+ 		}
+ 		printf ("\n");
+ 	    }
+ 	}
+ 
++        size = _compute_xrender_bitmap_size( &local, glyphslot, mode );
++        if ( size < 0 )
++            continue;
++
++        xftg->metrics.width  = local.width;
++	xftg->metrics.height = local.rows;
++	xftg->metrics.x      = - glyphslot->bitmap_left;
++	xftg->metrics.y      =   glyphslot->bitmap_top;
++	    
++	    /*
++	 * If the glyph is relatively large (> 1% of server memory),
++	 * don't send it until necessary
++	     */
++	if (!need_bitmaps && size > info->max_glyph_memory / 100)
++	    continue;
++
++	/*
++	 * Make sure there's enough buffer space for the glyph
++	 */
++	if (size > bufSize)
++	    {
++	    if (bufBitmap != bufLocal)
++		free (bufBitmap);
++	    bufBitmap = (unsigned char *) malloc (size);
++	    if (!bufBitmap)
++		    continue;
++	    bufSize = size;
++	    }
++	memset (bufBitmap, 0, size);
++
++        local.buffer = bufBitmap;
++	    
++        _fill_xrender_bitmap( &local, glyphslot, mode,
++                              (font->info.rgba == FC_RGBA_BGR  ||
++                               font->info.rgba == FC_RGBA_VBGR ) );
++	/*
++	 * Copy or convert into local buffer
++	 */
++
+ 	/*
+ 	 * Use the glyph index as the wire encoding; it
+ 	 * might be more efficient for some locales to map
+@@ -455,121 +677,23 @@
+ 	 */
+ 	glyph = (Glyph) glyphindex;
+ 
+-	if (subpixel)
+-	{
+-	    int		    x, y;
+-	    unsigned char   *in_line, *out_line, *in;
+-	    unsigned int    *out;
+-	    unsigned int    red, green, blue;
+-	    int		    rf, gf, bf;
+-	    int		    s;
+-	    int		    o, os;
+-	    
+-	    /*
+-	     * Filter the glyph to soften the color fringes
+-	     */
+-	    widthrgba = width;
+-	    pitchrgba = (widthrgba * 4 + 3) & ~3;
+-	    sizergba = pitchrgba * height;
+-
+-	    os = 1;
+-	    switch (font->info.rgba) {
+-	    case FC_RGBA_VRGB:
+-		os = pitch;
+-	    case FC_RGBA_RGB:
+-	    default:
+-		rf = 0;
+-		gf = 1;
+-		bf = 2;
+-		break;
+-	    case FC_RGBA_VBGR:
+-		os = pitch;
+-	    case FC_RGBA_BGR:
+-		bf = 0;
+-		gf = 1;
+-		rf = 2;
+-		break;
+-	    }
+-	    if (sizergba > bufSizeRgba)
+-	    {
+-		if (bufBitmapRgba != bufLocalRgba)
+-		    free (bufBitmapRgba);
+-		bufBitmapRgba = (unsigned char *) malloc (sizergba);
+-		if (!bufBitmapRgba)
+-		    continue;
+-		bufSizeRgba = sizergba;
+-	    }
+-	    memset (bufBitmapRgba, 0, sizergba);
+-	    in_line = bufBitmap;
+-	    out_line = bufBitmapRgba;
+-	    for (y = 0; y < height; y++)
+-	    {
+-		in = in_line;
+-		out = (unsigned int *) out_line;
+-		in_line += pitch * vmul;
+-		out_line += pitchrgba;
+-		for (x = 0; x < width * hmul; x += hmul)
+-		{
+-		    red = green = blue = 0;
+-		    o = 0;
+-		    for (s = 0; s < 3; s++)
+-		    {
+-			red += filters[rf][s]*in[x+o];
+-			green += filters[gf][s]*in[x+o];
+-			blue += filters[bf][s]*in[x+o];
+-			o += os;
+-		    }
+-		    red = red / 65536;
+-		    green = green / 65536;
+-		    blue = blue / 65536;
+-		    *out++ = (green << 24) | (red << 16) | (green << 8) | blue;
+-		}
+-	    }
+-	    
+-	    xftg->glyph_memory = sizergba + sizeof (XftGlyph);
+-	    if (font->format)
++	xftg->glyph_memory = size + sizeof (XftGlyph);
++ 	    if (font->format)
+ 	    {
+ 		if (!font->glyphset)
+ 		    font->glyphset = XRenderCreateGlyphSet (dpy, font->format);
+-		if (ImageByteOrder (dpy) != XftNativeByteOrder ())
+-		    XftSwapCARD32 ((CARD32 *) bufBitmapRgba, sizergba >> 2);
+-		XRenderAddGlyphs (dpy, font->glyphset, &glyph,
+-				  &xftg->metrics, 1, 
+-				  (char *) bufBitmapRgba, sizergba);
+-	    }
+-	    else
+-	    {
+-		if (sizergba)
+-		{
+-		    xftg->bitmap = malloc (sizergba);
+-		    if (xftg->bitmap)
+-			memcpy (xftg->bitmap, bufBitmapRgba, sizergba);
+-		}
+-		else
+-		    xftg->bitmap = NULL;
+-	    }
+-	}
+-	else
+-	{
+-	    xftg->glyph_memory = size + sizeof (XftGlyph);
+-	    if (font->format)
+-	    {
+-		/*
+-		 * swap bit order around; FreeType is always MSBFirst
+-		 */
+-		if (!font->info.antialias)
++	    if ( mode == FT_RENDER_MODE_MONO )
+ 		{
++		  /* swap bits in each byte */
+ 		    if (BitmapBitOrder (dpy) != MSBFirst)
+ 		    {
+-			unsigned char   *line;
+-			unsigned char   c;
+-			int		    i;
++		      unsigned char   *line = (unsigned char*)bufBitmap;
++		      int             i = size;
+ 
+-			line = (unsigned char *) bufBitmap;
+-			i = size;
+ 			while (i--)
+ 			{
+-			    c = *line;
++			  int  c = *line;
++
+ 			    c = ((c << 1) & 0xaa) | ((c >> 1) & 0x55);
+ 			    c = ((c << 2) & 0xcc) | ((c >> 2) & 0x33);
+ 			    c = ((c << 4) & 0xf0) | ((c >> 4) & 0x0f);
+@@ -577,8 +701,12 @@
+ 			}
+ 		    }
+ 		}
+-		if (!font->glyphset)
+-		    font->glyphset = XRenderCreateGlyphSet (dpy, font->format);
++            else if ( mode != FT_RENDER_MODE_NORMAL )
++            {
++                /* invert ARGB <=> BGRA */
++                if (ImageByteOrder (dpy) != XftNativeByteOrder ())
++                    XftSwapCARD32 ((CARD32 *) bufBitmap, size >> 2);
++            }
+ 		XRenderAddGlyphs (dpy, font->glyphset, &glyph,
+ 				  &xftg->metrics, 1, 
+ 				  (char *) bufBitmap, size);
+@@ -594,7 +722,7 @@
+ 		else
+ 		    xftg->bitmap = NULL;
+ 	    }
+-	}
++
+ 	font->glyph_memory += xftg->glyph_memory;
+ 	info->glyph_memory += xftg->glyph_memory;
+ 	if (XftDebug() & XFT_DBG_CACHE)
+@@ -605,8 +733,6 @@
+     }
+     if (bufBitmap != bufLocal)
+ 	free (bufBitmap);
+-    if (bufBitmapRgba != bufLocalRgba)
+-	free (bufBitmapRgba);
+     XftUnlockFace (&font->public);
+ }
+ 
+Index: xft/src/xftint.h
+===================================================================
+--- xft.orig/src/xftint.h	2009-12-04 15:42:00.000000000 +0200
++++ xft/src/xftint.h	2009-12-04 15:47:57.000000000 +0200
+@@ -145,6 +145,7 @@
+     FcBool		antialias;	/* doing antialiasing */
+     FcBool		embolden;	/* force emboldening */
+     int			rgba;		/* subpixel order */
++    int			lcd_filter;	/* lcd filter */
+     FT_Matrix		matrix;		/* glyph transformation matrix */
+     FcBool		transform;	/* non-identify matrix? */
+     FT_Int		load_flags;	/* glyph load flags */
diff -Naur libXft-2.1.14.orig/debian/patches/series libXft-2.1.14/debian/patches/series
--- libXft-2.1.14.orig/debian/patches/series	1970-01-01 01:00:00.000000000 +0100
+++ libXft-2.1.14/debian/patches/series	2010-02-20 14:45:51.000000000 +0100
@@ -0,0 +1,2 @@
+001_no_export_freetype.diff
+100-libXft-2.1.10-lcd-filter-3.patch
diff -Naur libXft-2.1.14.orig/debian/README.source libXft-2.1.14/debian/README.source
--- libXft-2.1.14.orig/debian/README.source	1970-01-01 01:00:00.000000000 +0100
+++ libXft-2.1.14/debian/README.source	2010-02-20 14:45:51.000000000 +0100
@@ -0,0 +1,73 @@
+------------------------------------------------------
+Quick Guide To Patching This Package For The Impatient
+------------------------------------------------------
+
+1. Make sure you have quilt installed
+2. Unpack the package as usual with "dpkg-source -x"
+3. Run the "patch" target in debian/rules
+4. Create a new patch with "quilt new" (see quilt(1))
+5. Edit all the files you want to include in the patch with "quilt edit" 
+   (see quilt(1)).
+6. Write the patch with "quilt refresh" (see quilt(1))
+7. Run the "clean" target in debian/rules
+
+Alternatively, instead of using quilt directly, you can drop the patch in to 
+debian/patches and add the name of the patch to debian/patches/series.
+
+------------------------------------
+Guide To The X Strike Force Packages
+------------------------------------
+
+The X Strike Force team maintains X packages in git repositories on
+git.debian.org in the pkg-xorg subdirectory. Most upstream packages
+are actually maintained in git repositories as well, so they often
+just need to be pulled into git.debian.org in a "upstream-*" branch.
+Otherwise, the upstream sources are manually installed in the Debian
+git repository.
+
+The .orig.tar.gz upstream source file could be generated this
+"upstream-*" branch in the Debian git repository but it is actually
+copied from upstream tarballs directly.
+
+Due to X.org being highly modular, packaging all X.org applications
+as their own independent packages would have created too many Debian
+packages. For this reason, some X.org applications have been grouped
+into larger packages: xutils, xutils-dev, x11-apps, x11-session-utils,
+x11-utils, x11-xfs-utils, x11-xkb-utils, x11-xserver-utils.
+Most packages, including the X.org server itself and all libraries
+and drivers are, however maintained independently.
+
+The Debian packaging is added by creating the "debian-*" git branch
+which contains the aforementioned "upstream-*" branch plus the debian/
+repository files.
+When a patch has to be applied to the Debian package, two solutions
+are involved:
+* If the patch is available in one of the upstream branches, it
+  may be git'cherry-picked into the Debian repository. In this
+  case, it appears directly in the .diff.gz.
+* Otherwise, the patch is added to debian/patches/ which is managed
+  with quilt as documented in /usr/share/doc/quilt/README.source.
+
+quilt is actually invoked by the Debian X packaging through a larger
+set of scripts called XSFBS. XSFBS brings some other X specific
+features such as managing dependencies and conflicts due to the video
+and input driver ABIs.
+XSFBS itself is maintained in a separate repository at
+  git://git.debian.org/pkg-xorg/xsfbs.git
+and it is pulled inside the other Debian X repositories when needed.
+
+The XSFBS patching system requires a build dependency on quilt. Also
+a dependency on $(STAMP_DIR)/patch has to be added to debian/rules
+so that the XSFBS patching occurs before the actual build. So the
+very first target of the build (likely the one running autoreconf)
+should depend on $(STAMP_DIR)/patch. It should also not depend on
+anything so that parallel builds are correctly supported (nothing
+should probably run while patching is being done). And finally, the
+clean target should depend on the xsfclean target so that patches
+are unapplied on clean.
+
+When the upstream sources contain some DFSG-nonfree files, they are
+listed in text files in debian/prune/ in the "debian-*" branch of
+the Debian repository. XSFBS' scripts then take care of removing
+these listed files during the build so as to generate a modified
+DFSG-free .orig.tar.gz tarball.
diff -Naur libXft-2.1.14.orig/debian/rules libXft-2.1.14/debian/rules
--- libXft-2.1.14.orig/debian/rules	1970-01-01 01:00:00.000000000 +0100
+++ libXft-2.1.14/debian/rules	2010-02-20 14:45:51.000000000 +0100
@@ -0,0 +1,101 @@
+#!/usr/bin/make -f
+# debian/rules for the Debian libxft package.
+# Copyright © 2004 Scott James Remnant <scott@netsplit.com>
+# Copyright © 2005 Daniel Stone <daniel@fooishbar.org>
+# Copyright © 2005 David Nusinow <dnusinow@debian.org>
+
+# Uncomment this to turn on verbose mode.
+#export DH_VERBOSE=1
+
+PACKAGE = libxft2
+
+include debian/xsfbs/xsfbs.mk
+
+CFLAGS = -Wall -g
+ifneq (,$(findstring noopt,$(DEB_BUILD_OPTIONS)))
+	CFLAGS += -O0
+else
+	CFLAGS += -O2
+endif
+ifneq (,$(filter parallel=%,$(DEB_BUILD_OPTIONS)))
+	NUMJOBS = $(patsubst parallel=%,%,$(filter parallel=%,$(DEB_BUILD_OPTIONS)))
+	MAKEFLAGS += -j$(NUMJOBS)
+endif
+
+
+DEB_HOST_ARCH      ?= $(shell dpkg-architecture -qDEB_HOST_ARCH)
+DEB_HOST_GNU_TYPE  ?= $(shell dpkg-architecture -qDEB_HOST_GNU_TYPE)
+DEB_BUILD_GNU_TYPE ?= $(shell dpkg-architecture -qDEB_BUILD_GNU_TYPE)
+ifeq ($(DEB_BUILD_GNU_TYPE), $(DEB_HOST_GNU_TYPE))
+	confflags += --build=$(DEB_HOST_GNU_TYPE)
+else
+	confflags += --build=$(DEB_BUILD_GNU_TYPE) --host=$(DEB_HOST_GNU_TYPE)
+endif
+
+configure: $(STAMP_DIR)/patch
+	dh_testdir
+	autoreconf -vfi
+
+obj-$(DEB_BUILD_GNU_TYPE)/config.status: configure
+	dh_testdir
+	test -d obj-$(DEB_BUILD_GNU_TYPE) || mkdir obj-$(DEB_BUILD_GNU_TYPE)
+	cd obj-$(DEB_BUILD_GNU_TYPE) && \
+	../configure --prefix=/usr --mandir=\$${prefix}/share/man \
+	             --infodir=\$${prefix}/share/info $(confflags) \
+	             CFLAGS="$(CFLAGS)" 
+
+build: build-stamp
+build-stamp: obj-$(DEB_BUILD_GNU_TYPE)/config.status
+	dh_testdir
+	cd obj-$(DEB_BUILD_GNU_TYPE) && $(MAKE)
+	>$@
+
+clean: xsfclean
+	dh_testdir
+	dh_testroot
+	rm -f build-stamp
+
+	rm -f config.cache config.log config.status
+	rm -f */config.cache */config.log */config.status
+	rm -f conftest* */conftest*
+	rm -rf autom4te.cache */autom4te.cache
+	rm -rf obj-*
+	rm -f $$(find -name Makefile.in)
+	rm -f compile config.guess config.sub configure depcomp install-sh
+	rm -f ltmain.sh missing INSTALL aclocal.m4 config.h.in mkinstalldirs
+
+	dh_clean
+
+install: build
+	dh_testdir
+	dh_testroot
+	dh_clean -k
+	dh_installdirs
+
+	cd obj-$(DEB_BUILD_GNU_TYPE) && $(MAKE) DESTDIR=$(CURDIR)/debian/tmp install
+
+# Build architecture-dependent files here.
+binary-arch: build install
+	dh_testdir
+	dh_testroot
+
+	dh_installdocs
+	dh_install --sourcedir=debian/tmp --list-missing
+	dh_installchangelogs ChangeLog
+	dh_link
+	dh_strip --dbg-package=$(PACKAGE)-dbg
+	dh_compress
+	dh_fixperms
+	dh_makeshlibs -V "libxft2 (>> 2.1.1)"
+	dh_shlibdeps
+	dh_installdeb
+	dh_gencontrol
+	dh_md5sums
+	dh_builddeb
+
+# Build architecture-independent files here.
+binary-indep: build install
+# Nothing to do
+
+binary: binary-indep binary-arch
+.PHONY: build clean binary-indep binary-arch binary install
diff -Naur libXft-2.1.14.orig/debian/watch libXft-2.1.14/debian/watch
--- libXft-2.1.14.orig/debian/watch	1970-01-01 01:00:00.000000000 +0100
+++ libXft-2.1.14/debian/watch	2010-02-20 14:45:51.000000000 +0100
@@ -0,0 +1,2 @@
+version=3
+http://xorg.freedesktop.org/releases/individual/lib/ libXft-(.*)\.tar\.gz
diff -Naur libXft-2.1.14.orig/debian/xsfbs/repack.sh libXft-2.1.14/debian/xsfbs/repack.sh
--- libXft-2.1.14.orig/debian/xsfbs/repack.sh	1970-01-01 01:00:00.000000000 +0100
+++ libXft-2.1.14/debian/xsfbs/repack.sh	2010-02-20 14:45:51.000000000 +0100
@@ -0,0 +1,32 @@
+#!/bin/sh
+
+set -e
+
+if ! [ -d debian/prune ]; then
+	exit 0
+fi
+
+if [ "x$1" != x--upstream-version ]; then
+	exit 1
+fi
+
+version="$2"
+filename="$3"
+
+if [ -z "$version" ] || ! [ -f "$filename" ]; then
+	exit 1
+fi
+
+dir="$(pwd)"
+tempdir="$(mktemp -d)"
+
+cd "$tempdir"
+tar xf "$dir/$filename"
+cat "$dir"/debian/prune/* | while read file; do rm -f */$file; done
+
+tar czf "$dir/$filename" *
+cd "$dir"
+rm -rf "$tempdir"
+echo "Done pruning upstream tarball"
+
+exit 0
diff -Naur libXft-2.1.14.orig/debian/xsfbs/xsfbs.mk libXft-2.1.14/debian/xsfbs/xsfbs.mk
--- libXft-2.1.14.orig/debian/xsfbs/xsfbs.mk	1970-01-01 01:00:00.000000000 +0100
+++ libXft-2.1.14/debian/xsfbs/xsfbs.mk	2010-02-20 14:45:51.000000000 +0100
@@ -0,0 +1,276 @@
+#!/usr/bin/make -f
+
+# Debian X Strike Force Build System (XSFBS): Make portion
+
+# Copyright 1996 Stephen Early
+# Copyright 1997 Mark Eichin
+# Copyright 1998-2005, 2007 Branden Robinson
+# Copyright 2005 David Nusinow
+#
+# Licensed under the GNU General Public License, version 2.  See the file
+# /usr/share/common-licenses/GPL or <http://www.gnu.org/copyleft/gpl.txt>.
+
+# Originally by Stephen Early <sde1000@debian.org>
+# Modified by Mark W. Eichin <eichin@kitten.gen.ma.us>
+# Modified by Adam Heath <doogie@debian.org>
+# Modified by Branden Robinson <branden@debian.org>
+# Modified by Fabio Massimo Di Nitto <fabbione@fabbione.net>
+# Modified by David Nusinow <dnusinow@debian.org>
+# Acknowledgements to Manoj Srivastava.
+
+# Pass $(DH_OPTIONS) into the environment for debhelper's benefit.
+export DH_OPTIONS
+
+# force quilt to not use ~/.quiltrc and to use debian/patches
+QUILT = QUILT_PATCHES=debian/patches quilt --quiltrc /dev/null
+
+# Set up parameters for the upstream build environment.
+
+# Determine (source) package name from Debian changelog.
+SOURCE_NAME:=$(shell dpkg-parsechangelog -ldebian/changelog \
+                        | grep '^Source:' | awk '{print $$2}')
+
+# Determine package version from Debian changelog.
+SOURCE_VERSION:=$(shell dpkg-parsechangelog -ldebian/changelog \
+                        | grep '^Version:' | awk '{print $$2}')
+
+# Determine upstream version number.
+UPSTREAM_VERSION:=$(shell echo $(SOURCE_VERSION) | sed 's/-.*//')
+
+# Determine the source version without the epoch for make-orig-tar-gz
+NO_EPOCH_VER:=$(shell echo $(UPSTREAM_VERSION) | sed 's/^.://')
+
+# Figure out who's building this package.
+BUILDER:=$(shell echo $${DEBEMAIL:-$${EMAIL:-$$(echo $$LOGNAME@$$(cat /etc/mailname 2>/dev/null))}})
+
+# Find out if this is an official build; an official build has nothing but
+# digits, dots, and/or the codename of a release in the Debian part of the
+# version number.  Anything else indicates an unofficial build.
+OFFICIAL_BUILD:=$(shell VERSION=$(SOURCE_VERSION); if ! expr "$$(echo $${VERSION\#\#*-} | sed 's/\(woody\|sarge\|etch\|lenny\)//g')" : ".*[^0-9.].*" >/dev/null 2>&1; then echo yes; fi)
+
+# Set up parameters for the Debian build environment.
+
+# Determine our architecture.
+BUILD_ARCH:=$(shell dpkg-architecture -qDEB_BUILD_ARCH)
+# Work around some old-time dpkg braindamage.
+BUILD_ARCH:=$(subst i486,i386,$(BUILD_ARCH))
+# The DEB_HOST_ARCH variable may be set per the Debian cross-compilation policy.
+ifdef DEB_HOST_ARCH
+ ARCH:=$(DEB_HOST_ARCH)
+else
+ # dpkg-cross sets the ARCH environment variable; if set, use it.
+ ifdef ARCH
+  ARCH:=$(ARCH)
+ else
+  ARCH:=$(BUILD_ARCH)
+ endif
+endif
+
+# $(STAMP_DIR) houses stamp files for complex targets.
+STAMP_DIR:=stampdir
+
+# $(DEBTREEDIR) is where all install rules are told (via $(DESTDIR)) to place
+# their files.
+DEBTREEDIR:=$(CURDIR)/debian/tmp
+
+# All "important" targets have four lines:
+#   1) A target name that is invoked by a package-building tool or the user.
+#      This consists of a dependency on a "$(STAMP_DIR)/"-prefixed counterpart.
+#   2) A line delcaring 1) as a phony target (".PHONY:").
+#   3) A "$(STAMP_DIR)/"-prefixed target which does the actual work, and may
+#   depend on other targets.
+#   4) A line declaring 3) as a member of the $(stampdir_targets) variable; the
+#   "$(STAMP_DIR)/" prefix is omitted.
+#
+# This indirection is needed so that the "stamp" files that signify when a rule
+# is done can be located in a separate "stampdir".  Recall that make has no way
+# to know when a goal has been met for a phony target (like "build" or
+# "install").
+#
+# At the end of each "$(STAMP_DIR)/" target, be sure to run the command ">$@"
+# so that the target will not be run again.  Removing the file will make Make
+# run the target over.
+
+# All phony targets should be declared as dependencies of .PHONY, even if they
+# do not have "($STAMP_DIR)/"-prefixed counterparts.
+
+# Define a harmless default rule to keep things from going nuts by accident.
+.PHONY: default
+default:
+
+# Set up the $(STAMP_DIR) directory.
+.PHONY: stampdir
+stampdir_targets+=stampdir
+stampdir: $(STAMP_DIR)/stampdir
+$(STAMP_DIR)/stampdir:
+	mkdir $(STAMP_DIR)
+	>$@
+
+# Set up the package build directory as quilt expects to find it.
+.PHONY: prepare
+stampdir_targets+=prepare
+prepare: $(STAMP_DIR)/prepare
+$(STAMP_DIR)/prepare: $(STAMP_DIR)/log $(STAMP_DIR)/genscripts
+	>$@
+
+.PHONY: log
+stampdir_targets+=log
+log: $(STAMP_DIR)/log
+$(STAMP_DIR)/log: $(STAMP_DIR)/stampdir
+	mkdir -p $(STAMP_DIR)/log
+
+# Apply all patches to the upstream source.
+.PHONY: patch
+stampdir_targets+=patch
+patch: $(STAMP_DIR)/patch
+$(STAMP_DIR)/patch: $(STAMP_DIR)/prepare
+	if ! [ `which quilt` ]; then \
+		echo "Couldn't find quilt. Please install it or add it to the build-depends for this package."; \
+		exit 1; \
+	fi; \
+	if $(QUILT) next >/dev/null 2>&1; then \
+	  echo -n "Applying patches..."; \
+	  if $(QUILT) push -a -v >$(STAMP_DIR)/log/patch 2>&1; then \
+	    cat $(STAMP_DIR)/log/patch; \
+	    echo "successful."; \
+	  else \
+	    cat $(STAMP_DIR)/log/patch; \
+	    echo "failed! (check $(STAMP_DIR)/log/patch for details)"; \
+	    exit 1; \
+	  fi; \
+	else \
+	  echo "No patches to apply"; \
+	fi; \
+	>$@
+
+# Revert all patches to the upstream source.
+.PHONY: unpatch
+unpatch: $(STAMP_DIR)/log
+	rm -f $(STAMP_DIR)/patch
+	@echo -n "Unapplying patches..."; \
+	if $(QUILT) applied >/dev/null 2>/dev/null; then \
+	  if $(QUILT) pop -a -v >$(STAMP_DIR)/log/unpatch 2>&1; then \
+	    cat $(STAMP_DIR)/log/unpatch; \
+	    echo "successful."; \
+	  else \
+	    cat $(STAMP_DIR)/log/unpatch; \
+	    echo "failed! (check $(STAMP_DIR)/log/unpatch for details)"; \
+	    exit 1; \
+	  fi; \
+	else \
+	  echo "nothing to do."; \
+	fi
+
+# Clean the generated maintainer scripts.
+.PHONY: cleanscripts
+cleanscripts:
+	rm -f $(STAMP_DIR)/genscripts
+	rm -f debian/*.config \
+	      debian/*.postinst \
+	      debian/*.postrm \
+	      debian/*.preinst \
+	      debian/*.prerm
+
+# Clean the package build tree.
+.PHONY: xsfclean
+xsfclean: cleanscripts unpatch
+	dh_testdir
+	rm -rf .pc
+	rm -rf $(STAMP_DIR)
+	dh_clean
+
+# Remove files from the upstream source tree that we don't need, or which have
+# licensing problems.  It must be run before creating the .orig.tar.gz.
+#
+# Note: This rule is for Debian package maintainers' convenience, and is not
+# needed for conventional build scenarios.
+.PHONY: prune-upstream-tree
+prune-upstream-tree:
+	# Ensure we're in the correct directory.
+	dh_testdir
+	grep -rvh '^#' debian/prune/ | xargs --no-run-if-empty rm -rf
+
+# Verify that there are no offsets or fuzz in the patches we apply.
+#
+# Note: This rule is for Debian package maintainers' convenience, and is not
+# needed for conventional build scenarios.
+.PHONY: patch-audit
+patch-audit: prepare unpatch
+	@echo -n "Auditing patches..."; \
+	>$(STAMP_DIR)/log/patch; \
+	FUZZY=; \
+	while [ -n "$$($(QUILT) next)" ]; do \
+	  RESULT=$$($(QUILT) push -v | tee -a $(STAMP_DIR)/log/patch | grep ^Hunk | sed 's/^Hunk.*\(succeeded\|FAILED\).*/\1/');\
+	  case "$$RESULT" in \
+	    succeeded) \
+	      echo "fuzzy patch: $$($(QUILT) top)" \
+	        | tee -a $(STAMP_DIR)/log/$$($(QUILT) top); \
+	      FUZZY=yes; \
+	      ;; \
+	    FAILED) \
+	      echo "broken patch: $$($(QUILT) next)" \
+	        | tee -a $(STAMP_DIR)/log/$$($(QUILT) next); \
+	      exit 1; \
+	      ;; \
+	  esac; \
+	done; \
+	if [ -n "$$FUZZY" ]; then \
+	  echo "there were fuzzy patches; please fix."; \
+	  exit 1; \
+	else \
+	  echo "done."; \
+	fi
+
+# Generate the maintainer scripts.
+.PHONY: genscripts
+stampdir_targets+=genscripts
+genscripts: $(STAMP_DIR)/genscripts
+$(STAMP_DIR)/genscripts: $(STAMP_DIR)/stampdir
+	for FILE in debian/*.config.in \
+	            debian/*.postinst.in \
+	            debian/*.postrm.in \
+	            debian/*.preinst.in \
+	            debian/*.prerm.in; do \
+	  if [ -e "$$FILE" ]; then \
+	    MAINTSCRIPT=$$(echo $$FILE | sed 's/.in$$//'); \
+	    sed -n '1,/^#INCLUDE_SHELL_LIB#$$/p' <$$FILE \
+	      | sed -e '/^#INCLUDE_SHELL_LIB#$$/d' >$$MAINTSCRIPT.tmp; \
+	    cat debian/xsfbs/xsfbs.sh >>$$MAINTSCRIPT.tmp; \
+	    sed -n '/^#INCLUDE_SHELL_LIB#$$/,$$p' <$$FILE \
+	      | sed -e '/^#INCLUDE_SHELL_LIB#$$/d' >>$$MAINTSCRIPT.tmp; \
+	    sed -e 's/@SOURCE_VERSION@/$(SOURCE_VERSION)/' \
+	        -e 's/@OFFICIAL_BUILD@/$(OFFICIAL_BUILD)/' \
+	      <$$MAINTSCRIPT.tmp >$$MAINTSCRIPT; \
+	    rm $$MAINTSCRIPT.tmp; \
+	  fi; \
+	done
+	# Validate syntax of generated shell scripts.
+	#sh debian/scripts/validate-posix-sh debian/*.config \
+	#                                    debian/*.postinst \
+	#                                    debian/*.postrm \
+	#                                    debian/*.preinst \
+	#                                    debian/*.prerm
+	>$@
+
+SERVERMINVERS = $(shell cat /usr/share/xserver-xorg/serverminver 2>/dev/null)
+VIDEOABI = $(shell cat /usr/share/xserver-xorg/videoabiver 2>/dev/null)
+INPUTABI = $(shell cat /usr/share/xserver-xorg/inputabiver 2>/dev/null)
+SERVER_DEPENDS = xserver-xorg-core (>= $(SERVERMINVERS))
+VIDDRIVER_PROVIDES = xserver-xorg-video-$(VIDEOABI)
+INPDRIVER_PROVIDES = xserver-xorg-input-$(INPUTABI)
+ifeq ($(PACKAGE),)
+PACKAGE=$(shell awk '/^Package:/ { print $$2; exit }' < debian/control)
+endif
+
+.PHONY: serverabi
+serverabi: install
+ifeq ($(SERVERMINVERS),)
+	@echo error: xserver-xorg-dev needs to be installed
+	@exit 1
+else
+	echo "xserver:Depends=$(SERVER_DEPENDS)" >> debian/$(PACKAGE).substvars
+	echo "xviddriver:Provides=$(VIDDRIVER_PROVIDES)" >> debian/$(PACKAGE).substvars
+	echo "xinpdriver:Provides=$(INPDRIVER_PROVIDES)" >> debian/$(PACKAGE).substvars
+endif
+
+# vim:set noet ai sts=8 sw=8 tw=0:
diff -Naur libXft-2.1.14.orig/debian/xsfbs/xsfbs.sh libXft-2.1.14/debian/xsfbs/xsfbs.sh
--- libXft-2.1.14.orig/debian/xsfbs/xsfbs.sh	1970-01-01 01:00:00.000000000 +0100
+++ libXft-2.1.14/debian/xsfbs/xsfbs.sh	2010-02-20 14:45:51.000000000 +0100
@@ -0,0 +1,622 @@
+# This is the X Strike Force shell library for X Window System package
+# maintainer scripts.  It serves to define shell functions commonly used by
+# such packages, and performs some error checking necessary for proper operation
+# of those functions.  By itself, it does not "do" much; the maintainer scripts
+# invoke the functions defined here to accomplish package installation and
+# removal tasks.
+
+# If you are reading this within a Debian package maintainer script (e.g.,
+# /var/lib/dpkg/info/PACKAGE.{config,preinst,postinst,prerm,postrm}), you can
+# skip past this library by scanning forward in this file to the string
+# "GOBSTOPPER".
+
+SOURCE_VERSION=@SOURCE_VERSION@
+OFFICIAL_BUILD=@OFFICIAL_BUILD@
+
+# Use special abnormal exit codes so that problems with this library are more
+# easily tracked down.
+SHELL_LIB_INTERNAL_ERROR=86
+SHELL_LIB_THROWN_ERROR=74
+SHELL_LIB_USAGE_ERROR=99
+
+# old -> new variable names
+if [ -z "$DEBUG_XORG_PACKAGE" ] && [ -n "$DEBUG_XFREE86_PACKAGE" ]; then
+  DEBUG_XORG_PACKAGE="$DEBUG_XFREE86_PACKAGE"
+fi
+if [ -z "$DEBUG_XORG_DEBCONF" ] && [ -n "$DEBUG_XFREE86_DEBCONF" ]; then
+  DEBUG_XORG_DEBCONF="$DEBUG_XFREE86_DEBCONF"
+fi
+
+# initial sanity checks
+if [ -z "$THIS_PACKAGE" ]; then
+  cat >&2 <<EOF
+Error: package maintainer script attempted to use shell library without
+definining \$THIS_PACKAGE shell variable.  Please report the package name,
+version, and the text of this error message to the Debian Bug Tracking System.
+Visit <http://www.debian.org/Bugs/Reporting> on the World Wide Web for
+instructions, read the file /usr/share/doc/debian/bug-reporting.txt from the
+"doc-debian" package, or install the "reportbug" package and use the command of
+the same name to file a report against version $SOURCE_VERSION of this package.
+EOF
+  exit $SHELL_LIB_USAGE_ERROR
+fi
+
+if [ -z "$THIS_SCRIPT" ]; then
+  cat >&2 <<EOF
+Error: package maintainer script attempted to use shell library without
+definining \$THIS_SCRIPT shell variable.  Please report the package name,
+version, and the text of this error message to the Debian Bug Tracking System.
+Visit <http://www.debian.org/Bugs/Reporting> on the World Wide Web for
+instructions, read the file /usr/share/doc/debian/bug-reporting.txt from the
+"doc-debian" package, or install the "reportbug" package and use the command of
+the same name to file a report against version $SOURCE_VERSION of the
+"$THIS_PACKAGE" package.
+EOF
+  exit $SHELL_LIB_USAGE_ERROR
+fi
+
+if [ "$1" = "reconfigure" ] || [ -n "$DEBCONF_RECONFIGURE" ]; then
+  RECONFIGURE="true"
+else
+  RECONFIGURE=
+fi
+
+if ([ "$1" = "install" ] || [ "$1" = "configure" ]) && [ -z "$2" ]; then
+  FIRSTINST="yes"
+fi
+
+if [ -z "$RECONFIGURE" ] && [ -z "$FIRSTINST" ]; then
+  UPGRADE="yes"
+fi
+
+trap "message;\
+      message \"Received signal.  Aborting $THIS_PACKAGE package $THIS_SCRIPT script.\";\
+      message;\
+      exit 1" HUP INT QUIT TERM
+
+reject_nondigits () {
+  # syntax: reject_nondigits [ operand ... ]
+  #
+  # scan operands (typically shell variables whose values cannot be trusted) for
+  # characters other than decimal digits and barf if any are found
+  while [ -n "$1" ]; do
+    # does the operand contain anything but digits?
+    if ! expr "$1" : "[[:digit:]]\+$" > /dev/null 2>&1; then
+      # can't use die(), because it wraps message() which wraps this function
+      echo "$THIS_PACKAGE $THIS_SCRIPT error: reject_nondigits() encountered" \
+           "possibly malicious garbage \"$1\"" >&2
+      exit $SHELL_LIB_THROWN_ERROR
+    fi
+    shift
+  done
+}
+
+reject_unlikely_path_chars () {
+  # syntax: reject_unlikely_path_chars [ operand ... ]
+  #
+  # scan operands (typically shell variables whose values cannot be trusted) for
+  # characters unlikely to be seen in a path and which the shell might
+  # interpret and barf if any are found
+  while [ -n "$1" ]; do
+    # does the operand contain any funny characters?
+    if expr "$1" : '.*[!$&()*;<>?|].*' > /dev/null 2>&1; then
+      # can't use die(), because I want to avoid forward references
+      echo "$THIS_PACKAGE $THIS_SCRIPT error: reject_unlikely_path_chars()" \
+           "encountered possibly malicious garbage \"$1\"" >&2
+      exit $SHELL_LIB_THROWN_ERROR
+    fi
+    shift
+  done
+}
+
+# Query the terminal to establish a default number of columns to use for
+# displaying messages to the user.  This is used only as a fallback in the
+# event the COLUMNS variable is not set.  ($COLUMNS can react to SIGWINCH while
+# the script is running, and this cannot, only being calculated once.)
+DEFCOLUMNS=$(stty size 2> /dev/null | awk '{print $2}') || true
+if ! expr "$DEFCOLUMNS" : "[[:digit:]]\+$" > /dev/null 2>&1; then
+  DEFCOLUMNS=80
+fi
+
+message () {
+  # pretty-print messages of arbitrary length
+  reject_nondigits "$COLUMNS"
+  echo "$*" | fmt -t -w ${COLUMNS:-$DEFCOLUMNS} >&2
+}
+
+observe () {
+  # syntax: observe message ...
+  #
+  # issue observational message suitable for logging someday when support for
+  # it exists in dpkg
+  if [ -n "$DEBUG_XORG_PACKAGE" ]; then
+    message "$THIS_PACKAGE $THIS_SCRIPT note: $*"
+  fi
+}
+
+warn () {
+  # syntax: warn message ...
+  #
+  # issue warning message suitable for logging someday when support for
+  # it exists in dpkg; also send to standard error
+  message "$THIS_PACKAGE $THIS_SCRIPT warning: $*"
+}
+
+die () {
+  # syntax: die message ...
+  #
+  # exit script with error message
+  message "$THIS_PACKAGE $THIS_SCRIPT error: $*"
+  exit $SHELL_LIB_THROWN_ERROR
+}
+
+internal_error () {
+  # exit script with error; essentially a "THIS SHOULD NEVER HAPPEN" message
+  message "internal error: $*"
+  if [ -n "$OFFICIAL_BUILD" ]; then
+    message "Please report a bug in the $THIS_SCRIPT script of the" \
+            "$THIS_PACKAGE package, version $SOURCE_VERSION to the Debian Bug" \
+            "Tracking System.  Include all messages above that mention the" \
+            "$THIS_PACKAGE package.  Visit " \
+            "<http://www.debian.org/Bugs/Reporting> on the World Wide Web for" \
+            "instructions, read the file" \
+            "/usr/share/doc/debian/bug-reporting.txt from the doc-debian" \
+            "package, or install the reportbug package and use the command of" \
+            "the same name to file a report."
+  fi
+  exit $SHELL_LIB_INTERNAL_ERROR
+}
+
+usage_error () {
+  message "usage error: $*"
+  message "Please report a bug in the $THIS_SCRIPT script of the" \
+          "$THIS_PACKAGE package, version $SOURCE_VERSION to the Debian Bug" \
+          "Tracking System.  Include all messages above that mention the" \
+          "$THIS_PACKAGE package.  Visit " \
+          "<http://www.debian.org/Bugs/Reporting> on the World Wide Web for" \
+          "instructions, read the file" \
+          "/usr/share/doc/debian/bug-reporting.txt from the doc-debian" \
+          "package, or install the reportbug package and use the command of" \
+          "the same name to file a report."
+  exit $SHELL_LIB_USAGE_ERROR
+}
+
+font_update () {
+  # run $UPDATECMDS in $FONTDIRS
+
+  local dir cmd shortcmd x_font_dir_prefix
+
+  x_font_dir_prefix="/usr/share/fonts/X11"
+
+  if [ -z "$UPDATECMDS" ]; then
+    usage_error "font_update() called but \$UPDATECMDS not set"
+  fi
+  if [ -z "$FONTDIRS" ]; then
+    usage_error "font_update() called but \$FONTDIRS not set"
+  fi
+
+  reject_unlikely_path_chars "$UPDATECMDS"
+  reject_unlikely_path_chars "$FONTDIRS"
+
+  for dir in $FONTDIRS; do
+    if [ -d "$x_font_dir_prefix/$dir" ]; then
+      for cmd in $UPDATECMDS; do
+        if which "$cmd" > /dev/null 2>&1; then
+          shortcmd=${cmd##*/}
+          observe "running $shortcmd in $dir font directory"
+	  cmd_opts=
+          if [ "$shortcmd" = "update-fonts-alias" ]; then
+            cmd_opts=--x11r7-layout
+          fi
+          if [ "$shortcmd" = "update-fonts-dir" ]; then
+            cmd_opts=--x11r7-layout
+          fi
+          if [ "$shortcmd" = "update-fonts-scale" ]; then
+            cmd_opts=--x11r7-layout
+          fi
+          $cmd $cmd_opts $dir || warn "$cmd $cmd_opts $dir" \
+                              "failed; font directory data may not" \
+                              "be up to date"
+        else
+          warn "$cmd not found; not updating corresponding $dir font" \
+               "directory data"
+        fi
+      done
+    else
+      warn "$dir is not a directory; not updating font directory data"
+    fi
+  done
+}
+
+remove_conffile_prepare () {
+  # syntax: remove_conffile_prepare filename official_md5sum ...
+  #
+  # Check a conffile "filename" against a list of canonical MD5 checksums.
+  # If the file's current MD5 checksum matches one of the "official_md5sum"
+  # operands provided, then prepare the conffile for removal from the system.
+  # We defer actual deletion until the package is configured so that we can
+  # roll this operation back if package installation fails.
+  #
+  # Call this function from a preinst script in the event $1 is "upgrade" or
+  # "install" and verify $2 to ensure the package is being upgraded from a
+  # version (or installed over a version removed-but-not-purged) prior to the
+  # one in which the conffile was obsoleted.
+
+  local conffile current_checksum
+
+  # validate arguments
+  if [ $# -lt 2 ]; then
+    usage_error "remove_conffile_prepare() called with wrong number of" \
+                "arguments; expected at least 2, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  conffile="$1"
+  shift
+
+  # does the conffile even exist?
+  if [ -e "$conffile" ]; then
+    # calculate its checksum
+    current_checksum=$(md5sum < "$conffile" | sed 's/[[:space:]].*//')
+    # compare it to each supplied checksum
+    while [ -n "$1" ]; do
+      if [ "$current_checksum" = "$1" ]; then
+        # we found a match; move the confffile and stop looking
+        observe "preparing obsolete conffile $conffile for removal"
+        mv "$conffile" "$conffile.$THIS_PACKAGE-tmp"
+        break
+      fi
+      shift
+    done
+  fi
+}
+
+remove_conffile_lookup () {
+  # syntax: remove_conffile_lookup package filename
+  #
+  # Lookup the md5sum of a conffile in dpkg's database, and prepare for removal
+  # if it matches the actual file's md5sum.
+  #
+  # Call this function when you would call remove_conffile_prepare but only
+  # want to check against dpkg's status database instead of known checksums.
+
+  local package conffile old_md5sum
+
+  # validate arguments
+  if [ $# -ne 2 ]; then
+    usage_error "remove_conffile_lookup() called with wrong number of" \
+                "arguments; expected 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  package="$1"
+  conffile="$2"
+
+  if ! [ -e "$conffile" ]; then
+    return
+  fi
+  old_md5sum="$(dpkg-query -W -f='${Conffiles}' "$package" | \
+    awk '{ if (match($0, "^ '"$conffile"' ")) print $2}')"
+  if [ -n "$old_md5sum" ]; then
+    remove_conffile_prepare "$conffile" "$old_md5sum"
+  fi
+}
+
+remove_conffile_commit () {
+  # syntax: remove_conffile_commit filename
+  #
+  # Complete the removal of a conffile "filename" that has become obsolete.
+  #
+  # Call this function from a postinst script after having used
+  # remove_conffile_prepare() in the preinst.
+
+  local conffile
+
+  # validate arguments
+  if [ $# -ne 1 ]; then
+    usage_error "remove_conffile_commit() called with wrong number of" \
+                "arguments; expected 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  conffile="$1"
+
+  # if the temporary file created by remove_conffile_prepare() exists, remove it
+  if [ -e "$conffile.$THIS_PACKAGE-tmp" ]; then
+    observe "committing removal of obsolete conffile $conffile"
+    rm "$conffile.$THIS_PACKAGE-tmp"
+  fi
+}
+
+remove_conffile_rollback () {
+  # syntax: remove_conffile_rollback filename
+  #
+  # Roll back the removal of a conffile "filename".
+  #
+  # Call this function from a postrm script in the event $1 is "abort-upgrade"
+  # or "abort-install" is  after having used remove_conffile_prepare() in the
+  # preinst.
+
+  local conffile
+
+  # validate arguments
+  if [ $# -ne 1 ]; then
+    usage_error "remove_conffile_rollback() called with wrong number of" \
+                "arguments; expected 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  conffile="$1"
+
+  # if the temporary file created by remove_conffile_prepare() exists, move it
+  # back
+  if [ -e "$conffile.$THIS_PACKAGE-tmp" ]; then
+    observe "rolling back removal of obsolete conffile $conffile"
+    mv "$conffile.$THIS_PACKAGE-tmp" "$conffile"
+  fi
+}
+
+replace_conffile_with_symlink_prepare () {
+  # syntax: replace_conffile_with_symlink_prepare oldfilename newfilename \
+  # official_md5sum ...
+  #
+  # Check a conffile "oldfilename" against a list of canonical MD5 checksums.
+  # If the file's current MD5 checksum matches one of the "official_md5sum"
+  # operands provided, then prepare the conffile for removal from the system.
+  # We defer actual deletion until the package is configured so that we can
+  # roll this operation back if package installation fails. Otherwise copy it
+  # to newfilename and let dpkg handle it through conffiles mechanism.
+  #
+  # Call this function from a preinst script in the event $1 is "upgrade" or
+  # "install" and verify $2 to ensure the package is being upgraded from a
+  # version (or installed over a version removed-but-not-purged) prior to the
+  # one in which the conffile was obsoleted.
+
+  local conffile current_checksum
+
+  # validate arguments
+  if [ $# -lt 3 ]; then
+    usage_error "replace_conffile_with_symlink_prepare() called with wrong" \
+                " number of arguments; expected at least 3, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  oldconffile="$1"
+  shift
+  newconffile="$1"
+  shift
+
+  remove_conffile_prepare "$_oldconffile" "$@"
+  # If $oldconffile still exists, then md5sums didn't match.
+  # Copy it to new one.
+  if [ -f "$oldconffile" ]; then
+    cp "$oldconffile" "$newconffile"
+  fi
+
+}
+
+replace_conffile_with_symlink_commit () {
+  # syntax: replace_conffile_with_symlink_commit oldfilename
+  #
+  # Complete the removal of a conffile "oldfilename" that has been
+  # replaced by a symlink.
+  #
+  # Call this function from a postinst script after having used
+  # replace_conffile_with_symlink_prepare() in the preinst.
+
+  local conffile
+
+  # validate arguments
+  if [ $# -ne 1 ]; then
+    usage_error "replace_conffile_with_symlink_commit() called with wrong" \
+                "number of arguments; expected 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  conffile="$1"
+
+  remove_conffile_commit "$conffile"
+}
+
+replace_conffile_with_symlink_rollback () {
+  # syntax: replace_conffile_with_symlink_rollback oldfilename newfilename
+  #
+  # Roll back the replacing of a conffile "oldfilename" with symlink to
+  # "newfilename".
+  #
+  # Call this function from a postrm script in the event $1 is "abort-upgrade"
+  # or "abort-install" and verify $2 to ensure the package failed to upgrade
+  # from a version (or install over a version removed-but-not-purged) prior
+  # to the one in which the conffile was obsoleted.
+  # You should have  used replace_conffile_with_symlink_prepare() in the
+  # preinst.
+
+  local conffile
+
+  # validate arguments
+  if [ $# -ne 2 ]; then
+    usage_error "replace_conffile_with_symlink_rollback() called with wrong" \
+                "number of arguments; expected 2, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  oldconffile="$1"
+  newconffile="$2"
+
+  remove_conffile_rollback "$_oldconffile"
+  if [ -f "$newconffile" ]; then
+    rm "$newconffile"
+  fi
+}
+
+run () {
+  # syntax: run command [ argument ... ]
+  #
+  # Run specified command with optional arguments and report its exit status.
+  # Useful for commands whose exit status may be nonzero, but still acceptable,
+  # or commands whose failure is not fatal to us.
+  #
+  # NOTE: Do *not* use this function with db_get or db_metaget commands; in
+  # those cases the return value of the debconf command *must* be checked
+  # before the string returned by debconf is used for anything.
+
+  local retval
+
+  # validate arguments
+  if [ $# -lt 1 ]; then
+    usage_error "run() called with wrong number of arguments; expected at" \
+                "least 1, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  "$@" || retval=$?
+
+  if [ ${retval:-0} -ne 0 ]; then
+    observe "command \"$*\" exited with status $retval"
+  fi
+}
+
+make_symlink_sane () {
+  # syntax: make_symlink_sane symlink target
+  #
+  # Ensure that the symbolic link symlink exists, and points to target.
+  #
+  # If symlink does not exist, create it and point it at target.
+  #
+  # If symlink exists but is not a symbolic link, back it up.
+  #
+  # If symlink exists, is a symbolic link, but points to the wrong location, fix
+  # it.
+  #
+  # If symlink exists, is a symbolic link, and already points to target, do
+  # nothing.
+  #
+  # This function wouldn't be needed if ln had an -I, --idempotent option.
+
+  # Validate arguments.
+  if [ $# -ne 2 ]; then
+    usage_error "make_symlink_sane() called with wrong number of arguments;" \
+      "expected 2, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  # We could just use the positional parameters as-is, but that makes things
+  # harder to follow.
+  local symlink target
+
+  symlink="$1"
+  target="$2"
+
+  if [ -L "$symlink" ] && [ "$(readlink "$symlink")" = "$target" ]; then
+      observe "link from $symlink to $target already exists"
+  else
+    observe "creating symbolic link from $symlink to $target"
+    mkdir -p "${target%/*}" "${symlink%/*}"
+    ln -s -b -S ".dpkg-old" "$target" "$symlink"
+  fi
+}
+
+migrate_dir_to_symlink () {
+  # syntax: migrate_dir_to_symlink old_location new_location
+  #
+  # Per Debian Policy section 6.5.4, "A directory will never be replaced by a
+  # symbolic link to a directory or vice versa; instead, the existing state
+  # (symlink or not) will be left alone and dpkg will follow the symlink if
+  # there is one."
+  #
+  # We have to do it ourselves.
+  #
+  # This function moves the contents of old_location, a directory, into
+  # new_location, a directory, then makes old_location a symbolic link to
+  # new_location.
+  #
+  # old_location need not exist, but if it does, it must be a directory (or a
+  # symlink to a directory).  If it is not, it is backed up.  If new_location
+  # exists already and is not a directory, it is backed up.
+  #
+  # This function should be called from a package's preinst so that other
+  # packages unpacked after this one --- but before this package's postinst runs
+  # --- are unpacked into new_location even if their payloads contain
+  # old_location filespecs.
+
+  # Validate arguments.
+  if [ $# -ne 2 ]; then
+    usage_error "migrate_dir_to_symlink() called with wrong number of"
+                "arguments; expected 2, got $#"
+    exit $SHELL_LIB_USAGE_ERROR
+  fi
+
+  # We could just use the positional parameters as-is, but that makes things
+  # harder to follow.
+  local new old
+
+  old="$1"
+  new="$2"
+
+  # Is old location a symlink?
+  if [ -L "$old" ]; then
+    # Does it already point to new location?
+    if [ "$(readlink "$old")" = "$new" ]; then
+      # Nothing to do; migration has already been done.
+      observe "migration of $old to $new already done"
+      return 0
+    else
+      # Back it up.
+      warn "backing up symbolic link $old as $old.dpkg-old"
+      mv -b "$old" "$old.dpkg-old"
+    fi
+  fi
+
+  # Does old location exist, but is not a directory?
+  if [ -e "$old" ] && ! [ -d "$old" ]; then
+      # Back it up.
+      warn "backing up non-directory $old as $old.dpkg-old"
+      mv -b "$old" "$old.dpkg-old"
+  fi
+
+  observe "migrating $old to $new"
+
+  # Is new location a symlink?
+  if [ -L "$new" ]; then
+    # Does it point the wrong way, i.e., back to where we're migrating from?
+    if [ "$(readlink "$new")" = "$old" ]; then
+      # Get rid of it.
+      observe "removing symbolic link $new which points to $old"
+      rm "$new"
+    else
+      # Back it up.
+      warn "backing up symbolic link $new as $new.dpkg-old"
+      mv -b "$new" "$new.dpkg-old"
+    fi
+  fi
+
+  # Does new location exist, but is not a directory?
+  if [ -e "$new" ] && ! [ -d "$new" ]; then
+    warn "backing up non-directory $new as $new.dpkg-old"
+    mv -b "$new" "$new.dpkg-old"
+  fi
+
+  # Create new directory if it does not yet exist.
+  if ! [ -e "$new" ]; then
+    observe "creating $new"
+    mkdir -p "$new"
+  fi
+
+  # Copy files in old location to new location.  Back up any filenames that
+  # already exist in the new location with the extension ".dpkg-old".
+  observe "copying files from $old to $new"
+  if ! (cd "$old" && cp -a -b -S ".dpkg-old" . "$new"); then
+    die "error(s) encountered while copying files from $old to $new"
+  fi
+
+  # Remove files at old location.
+  observe "removing $old"
+  rm -r "$old"
+
+  # Create symlink from old location to new location.
+  make_symlink_sane "$old" "$new"
+}
+
+# vim:set ai et sw=2 ts=2 tw=80:
+
+# GOBSTOPPER: The X Strike Force shell library ends here.
diff -Naur libXft-2.1.14.orig/src/xftdpy.c libXft-2.1.14/src/xftdpy.c
--- libXft-2.1.14.orig/src/xftdpy.c	2010-02-20 14:41:32.000000000 +0100
+++ libXft-2.1.14/src/xftdpy.c	2010-02-20 14:47:03.000000000 +0100
@@ -369,6 +369,10 @@
 	goto bail1;
     if (!_XftDefaultInitInteger (dpy, pat, FC_RGBA))
 	goto bail1;
+#ifdef FC_LCD_FILTER
+    if (!_XftDefaultInitInteger (dpy, pat, FC_LCD_FILTER))
+	goto bail1;
+#endif
     if (!_XftDefaultInitBool (dpy, pat, FC_ANTIALIAS))
 	goto bail1;
 #ifdef FC_EMBOLDEN
@@ -521,6 +525,14 @@
 			      XftDefaultGetInteger (dpy, FC_RGBA, screen, 
 						    subpixel));
     }
+#ifdef FC_LCD_FILTER
+    if (FcPatternGet (pattern, FC_LCD_FILTER, 0, &v) == FcResultNoMatch)
+    {
+	FcPatternAddInteger (pattern, FC_LCD_FILTER,
+			     XftDefaultGetInteger (dpy, FC_LCD_FILTER, screen,
+						   FC_LCD_DEFAULT));
+    }
+#endif
     if (FcPatternGet (pattern, FC_MINSPACE, 0, &v) == FcResultNoMatch)
     {
 	FcPatternAddBool (pattern, FC_MINSPACE,
diff -Naur libXft-2.1.14.orig/src/xftfreetype.c libXft-2.1.14/src/xftfreetype.c
--- libXft-2.1.14.orig/src/xftfreetype.c	2010-02-20 14:41:32.000000000 +0100
+++ libXft-2.1.14/src/xftfreetype.c	2010-02-20 14:47:04.000000000 +0100
@@ -469,6 +469,21 @@
 	goto bail1;
     }
     
+#ifdef FC_LCD_FILTER 
+    /*
+     * Get lcd_filter value
+     */
+    switch (FcPatternGetInteger (pattern, FC_LCD_FILTER, 0, &fi->lcd_filter)) {
+    case FcResultNoMatch:
+	fi->lcd_filter = FC_LCD_DEFAULT;
+	break;
+    case FcResultMatch:
+	break;
+    default:
+	goto bail1;
+    }
+#endif
+    
     /*
      * Get matrix and transform values
      */
diff -Naur libXft-2.1.14.orig/src/xftglyphs.c libXft-2.1.14/src/xftglyphs.c
--- libXft-2.1.14.orig/src/xftglyphs.c	2010-02-20 14:41:32.000000000 +0100
+++ libXft-2.1.14/src/xftglyphs.c	2010-02-20 14:47:04.000000000 +0100
@@ -21,27 +21,18 @@
  */
 
 #include "xftint.h"
-#include <freetype/ftoutln.h>
 
 #if HAVE_FT_GLYPHSLOT_EMBOLDEN
 #include <freetype/ftsynth.h>
 #endif
 
-static const int    filters[3][3] = {
-    /* red */
-#if 0
-{    65538*4/7,65538*2/7,65538*1/7 },
-    /* green */
-{    65536*1/4, 65536*2/4, 65537*1/4 },
-    /* blue */
-{    65538*1/7,65538*2/7,65538*4/7 },
+#if FREETYPE_MAJOR*10000 + FREETYPE_MINOR*100 + FREETYPE_PATCH < 20202
+#  error  "FreeType 2.2.2 or later required to compile this version of libXft"
 #endif
-{    65538*9/13,65538*3/13,65538*1/13 },
-    /* green */
-{    65538*1/6, 65538*4/6, 65538*1/6 },
-    /* blue */
-{    65538*1/13,65538*3/13,65538*9/13 },
-};
+
+#include FT_OUTLINE_H
+#include FT_LCD_FILTER_H
+#include FT_SYNTHESIS_H
 
 /*
  * Validate the memory info for a font
@@ -69,6 +60,295 @@
 		font->glyph_memory, glyph_memory);
 }
 
+
+/* we sometimes need to convert the glyph bitmap in a FT_GlyphSlot
+ * into a different format. For example, we want to convert a
+ * FT_PIXEL_MODE_LCD or FT_PIXEL_MODE_LCD_V bitmap into a 32-bit
+ * ARGB or ABGR bitmap.
+ *
+ * this function prepares a target descriptor for this operation.
+ *
+ * input :: target bitmap descriptor. The function will set its
+ *          'width', 'rows' and 'pitch' fields, and only these
+ *
+ * slot  :: the glyph slot containing the source bitmap. this
+ *          function assumes that slot->format == FT_GLYPH_FORMAT_BITMAP
+ *
+ * mode  :: the requested final rendering mode. supported values are
+ *          MONO, NORMAL (i.e. gray), LCD and LCD_V
+ *
+ * the function returns the size in bytes of the corresponding buffer,
+ * it's up to the caller to allocate the corresponding memory block
+ * before calling _fill_xrender_bitmap
+ *
+ * it also returns -1 in case of error (e.g. incompatible arguments,
+ * like trying to convert a gray bitmap into a monochrome one)
+ */
+static int
+_compute_xrender_bitmap_size( FT_Bitmap*      target,
+                              FT_GlyphSlot    slot,
+                              FT_Render_Mode  mode )
+{
+    FT_Bitmap*  ftbit;
+    int         width, height, pitch;
+
+    if ( slot->format != FT_GLYPH_FORMAT_BITMAP )
+        return -1;
+
+    // compute the size of the final bitmap
+    ftbit  = &slot->bitmap;
+
+    width  = ftbit->width;
+    height = ftbit->rows;
+    pitch  = (width+3) & ~3;
+
+    switch ( ftbit->pixel_mode )
+    {
+    case FT_PIXEL_MODE_MONO:
+        if ( mode == FT_RENDER_MODE_MONO )
+        {
+            pitch = (((width+31) & ~31) >> 3);
+            break;
+        }
+        /* fall-through */
+
+    case FT_PIXEL_MODE_GRAY:
+        if ( mode == FT_RENDER_MODE_LCD   ||
+             mode == FT_RENDER_MODE_LCD_V )
+        {
+          /* each pixel is replicated into a 32-bit ARGB value */
+          pitch = width*4;
+        }
+        break;
+
+    case FT_PIXEL_MODE_LCD:
+        if ( mode != FT_RENDER_MODE_LCD )
+            return -1;
+
+        /* horz pixel triplets are packed into 32-bit ARGB values */
+        width   /= 3;
+        pitch    = width*4;
+        break;
+
+    case FT_PIXEL_MODE_LCD_V:
+        if ( mode != FT_RENDER_MODE_LCD_V )
+            return -1;
+
+        /* vert pixel triplets are packed into 32-bit ARGB values */
+        height  /= 3;
+        pitch    = width*4;
+        break;
+
+    default:  /* unsupported source format */
+        return -1;
+    }
+
+    target->width  = width;
+    target->rows   = height;
+    target->pitch  = pitch;
+    target->buffer = NULL;
+
+    return pitch * height;
+}
+
+/* this functions converts the glyph bitmap found in a FT_GlyphSlot
+ * into a different format (see _compute_xrender_bitmap_size)
+ *
+ * you should call this function after _compute_xrender_bitmap_size
+ *
+ * target :: target bitmap descriptor. Note that its 'buffer' pointer
+ *           must point to memory allocated by the caller
+ *
+ * slot   :: the glyph slot containing the source bitmap
+ *
+ * mode   :: the requested final rendering mode
+ *
+ * bgr    :: boolean, set if BGR or VBGR pixel ordering is needed
+ */
+static void
+_fill_xrender_bitmap( FT_Bitmap*      target,
+                      FT_GlyphSlot    slot,
+                      FT_Render_Mode  mode,
+                      int             bgr )
+{
+    FT_Bitmap*   ftbit = &slot->bitmap;
+
+    {
+        unsigned char*   srcLine   = ftbit->buffer;
+        unsigned char*   dstLine   = target->buffer;
+        int              src_pitch = ftbit->pitch;
+        int              width     = target->width;
+        int              height    = target->rows;
+        int              pitch     = target->pitch;
+        int              subpixel;
+        int              h;
+
+        subpixel = ( mode == FT_RENDER_MODE_LCD ||
+                     mode == FT_RENDER_MODE_LCD_V );
+
+        if ( src_pitch < 0 )
+          srcLine -= src_pitch*(ftbit->rows-1);
+
+        switch ( ftbit->pixel_mode )
+        {
+        case FT_PIXEL_MODE_MONO:
+            if ( subpixel )  /* convert mono to ARGB32 values */
+            {
+                for ( h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch )
+                {
+                    int  x;
+
+                    for ( x = 0; x < width; x++ )
+                    {
+                        if ( srcLine[(x >> 3)] & (0x80 >> (x & 7)) )
+                            ((unsigned int*)dstLine)[x] = 0xffffffffU;
+                    }
+                }
+            }
+            else if ( mode == FT_RENDER_MODE_NORMAL )  /* convert mono to 8-bit gray */
+            {
+                for ( h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch )
+                {
+                    int  x;
+
+                    for ( x = 0; x < width; x++ )
+                    {
+                        if ( srcLine[(x >> 3)] & (0x80 >> (x & 7)) )
+                            dstLine[x] = 0xff;
+                    }
+                }
+            }
+            else  /* copy mono to mono */
+            {
+                int  bytes = (width+7) >> 3;
+
+                for ( h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch )
+                    memcpy( dstLine, srcLine, bytes );
+            }
+            break;
+
+        case FT_PIXEL_MODE_GRAY:
+            if ( subpixel )  /* convert gray to ARGB32 values */
+            {
+                for ( h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch )
+                {
+                    int            x;
+                    unsigned int*  dst = (unsigned int*)dstLine;
+
+                    for ( x = 0; x < width; x++ )
+                    {
+                        unsigned int  pix = srcLine[x];
+
+                        pix |= (pix << 8);
+                        pix |= (pix << 16);
+
+                        dst[x] = pix;
+                    }
+                }
+            }
+            else  /* copy gray into gray */
+            {
+                for ( h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch )
+                    memcpy( dstLine, srcLine, width );
+            }
+            break;
+
+        case FT_PIXEL_MODE_LCD:
+            if ( !bgr )
+            {
+                /* convert horizontal RGB into ARGB32 */
+                for ( h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch )
+                {
+                    int            x;
+                    unsigned char* src = srcLine;
+                    unsigned int*  dst = (unsigned int*)dstLine;
+
+                    for ( x = 0; x < width; x++, src += 3 )
+                    {
+                        unsigned int  pix;
+
+                        pix = ((unsigned int)src[0] << 16) |
+                              ((unsigned int)src[1] <<  8) |
+                              ((unsigned int)src[2]      ) |
+                              ((unsigned int)src[1] << 24) ;
+
+                        dst[x] = pix;
+                    }
+                }
+            }
+            else
+            {
+                /* convert horizontal BGR into ARGB32 */
+                for ( h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch )
+                {
+                    int            x;
+                    unsigned char* src = srcLine;
+                    unsigned int*  dst = (unsigned int*)dstLine;
+
+                    for ( x = 0; x < width; x++, src += 3 )
+                    {
+                        unsigned int  pix;
+
+                        pix = ((unsigned int)src[2] << 16) |
+                              ((unsigned int)src[1] <<  8) |
+                              ((unsigned int)src[0]      ) |
+                              ((unsigned int)src[1] << 24) ;
+
+                        dst[x] = pix;
+                    }
+                }
+            }
+            break;
+
+        default:  /* FT_PIXEL_MODE_LCD_V */
+            /* convert vertical RGB into ARGB32 */
+            if ( !bgr )
+            {
+                for ( h = height; h > 0; h--, srcLine += 3*src_pitch, dstLine += pitch )
+                {
+                    int            x;
+                    unsigned char* src = srcLine;
+                    unsigned int*  dst = (unsigned int*)dstLine;
+
+                    for ( x = 0; x < width; x++, src += 1 )
+                    {
+                        unsigned int  pix;
+
+                        pix = ((unsigned int)src[0]           << 16) |
+                              ((unsigned int)src[src_pitch]   <<  8) |
+                              ((unsigned int)src[src_pitch*2]      ) |
+                              ((unsigned int)src[src_pitch]   << 24) ;
+
+                        dst[x] = pix;
+                    }
+                }
+            }
+            else
+            {
+                for ( h = height; h > 0; h--, srcLine += 3*src_pitch, dstLine += pitch )
+                {
+                    int            x;
+                    unsigned char* src = srcLine;
+                    unsigned int*  dst = (unsigned int*)dstLine;
+
+                    for ( x = 0; x < width; x++, src += 1 )
+                    {
+                        unsigned int  pix;
+
+                        pix = ((unsigned int)src[src_pitch*2] << 16) |
+                              ((unsigned int)src[src_pitch]   <<  8) |
+                              ((unsigned int)src[0]                ) |
+                              ((unsigned int)src[src_pitch]   << 24) ;
+
+                        dst[x] = pix;
+                    }
+                }
+            }
+        }
+    }
+}
+
+
 _X_EXPORT void
 XftFontLoadGlyphs (Display	    *dpy,
 		   XftFont	    *pub,
@@ -87,20 +367,14 @@
     unsigned char   *bufBitmap = bufLocal;
     int		    bufSize = sizeof (bufLocal);
     int		    size, pitch;
-    unsigned char   bufLocalRgba[4096];
-    unsigned char   *bufBitmapRgba = bufLocalRgba;
-    int		    bufSizeRgba = sizeof (bufLocalRgba);
-    int		    sizergba, pitchrgba, widthrgba;
     int		    width;
     int		    height;
     int		    left, right, top, bottom;
-    int		    hmul = 1;
-    int		    vmul = 1;
-    FT_Bitmap	    ftbit;
-    FT_Matrix	    matrix;
+    FT_Bitmap*	    ftbit;
+    FT_Bitmap       local;
     FT_Vector	    vector;
-    Bool	    subpixel = False;
     FT_Face	    face;
+    FT_Render_Mode  mode = FT_RENDER_MODE_MONO;
 
     if (!info)
 	return;
@@ -110,24 +384,19 @@
     if (!face)
 	return;
 
-    matrix.xx = matrix.yy = 0x10000L;
-    matrix.xy = matrix.yx = 0;
-
     if (font->info.antialias)
     {
 	switch (font->info.rgba) {
 	case FC_RGBA_RGB:
 	case FC_RGBA_BGR:
-	    matrix.xx *= 3;
-	    subpixel = True;
-	    hmul = 3;
+	    mode = FT_RENDER_MODE_LCD;
 	    break;
 	case FC_RGBA_VRGB:
 	case FC_RGBA_VBGR:
-	    matrix.yy *= 3;
-	    vmul = 3;
-	    subpixel = True;
+            mode = FT_RENDER_MODE_LCD_V;
 	    break;
+        default:
+            mode = FT_RENDER_MODE_NORMAL;
 	}
     }
 
@@ -148,7 +417,10 @@
 	if (xftg->glyph_memory)
 	    continue;
 	
+        FT_Library_SetLcdFilter( _XftFTlibrary, font->info.lcd_filter);
+
 	error = FT_Load_Glyph (face, glyphindex, font->info.load_flags);
+
 	if (error)
 	{
 	    /*
@@ -181,7 +453,7 @@
 	/*
 	 * Compute glyph metrics from FreeType information
 	 */
-	if(font->info.transform && glyphslot->format != ft_glyph_format_bitmap) 
+	if(font->info.transform && glyphslot->format != FT_GLYPH_FORMAT_BITMAP)
 	{
 	    /*
 	     * calculate the true width by transforming all four corners.
@@ -260,17 +532,14 @@
 	    }
 	}
 
-	if (font->info.antialias)
-	    pitch = (width * hmul + 3) & ~3;
-	else
-	    pitch = ((width + 31) & ~31) >> 3;
-
-	size = pitch * height * vmul;
+        if ( glyphslot->format != FT_GLYPH_FORMAT_BITMAP )
+        {
+            error = FT_Render_Glyph( face->glyph, mode );
+            if (error)
+                continue;
+        }
 
-	xftg->metrics.width = width;
-	xftg->metrics.height = height;
-	xftg->metrics.x = -TRUNC(left);
-	xftg->metrics.y = TRUNC(top);
+        FT_Library_SetLcdFilter( _XftFTlibrary, FT_LCD_FILTER_NONE );
 
 	if (font->info.spacing >= FC_MONO)
 	{
@@ -310,103 +579,13 @@
 	    xftg->metrics.yOff = -TRUNC(ROUND(glyphslot->advance.y));
 	}
 	
-	/*
-	 * If the glyph is relatively large (> 1% of server memory),
-	 * don't send it until necessary
-	 */
-	if (!need_bitmaps && size > info->max_glyph_memory / 100)
-	    continue;
 	
-	/*
-	 * Make sure there's enough buffer space for the glyph
-	 */
-	if (size > bufSize)
-	{
-	    if (bufBitmap != bufLocal)
-		free (bufBitmap);
-	    bufBitmap = (unsigned char *) malloc (size);
-	    if (!bufBitmap)
-		continue;
-	    bufSize = size;
-	}
-	memset (bufBitmap, 0, size);
+        // compute the size of the final bitmap
+        ftbit  = &glyphslot->bitmap;
 
-	/*
-	 * Rasterize into the local buffer
-	 */
-	switch (glyphslot->format) {
-	case ft_glyph_format_outline:
-	    ftbit.width      = width * hmul;
-	    ftbit.rows       = height * vmul;
-	    ftbit.pitch      = pitch;
-	    if (font->info.antialias)
-		ftbit.pixel_mode = ft_pixel_mode_grays;
-	    else
-		ftbit.pixel_mode = ft_pixel_mode_mono;
-	    
-	    ftbit.buffer     = bufBitmap;
-	    
-	    if (subpixel)
-		FT_Outline_Transform (&glyphslot->outline, &matrix);
-
-	    FT_Outline_Translate ( &glyphslot->outline, -left*hmul, -bottom*vmul );
-
-	    FT_Outline_Get_Bitmap( _XftFTlibrary, &glyphslot->outline, &ftbit );
-	    break;
-	case ft_glyph_format_bitmap:
-	    if (font->info.antialias)
-	    {
-		unsigned char	*srcLine, *dstLine;
-		int		height;
-		int		x;
-		int	    h, v;
-
-		srcLine = glyphslot->bitmap.buffer;
-		dstLine = bufBitmap;
-		height = glyphslot->bitmap.rows;
-		while (height--)
-		{
-		    for (x = 0; x < glyphslot->bitmap.width; x++)
-		    {
-			/* always MSB bitmaps */
-			unsigned char	a = ((srcLine[x >> 3] & (0x80 >> (x & 7))) ?
-					     0xff : 0x00);
-			if (subpixel)
-			{
-			    for (v = 0; v < vmul; v++)
-				for (h = 0; h < hmul; h++)
-				    dstLine[v * pitch + x*hmul + h] = a;
-			}
-			else
-			    dstLine[x] = a;
-		    }
-		    dstLine += pitch * vmul;
-		    srcLine += glyphslot->bitmap.pitch;
-		}
-	    }
-	    else
-	    {
-		unsigned char	*srcLine, *dstLine;
-		int		h, bytes;
-
-		srcLine = glyphslot->bitmap.buffer;
-		dstLine = bufBitmap;
-		h = glyphslot->bitmap.rows;
-		bytes = (glyphslot->bitmap.width + 7) >> 3;
-		while (h--)
-		{
-		    memcpy (dstLine, srcLine, bytes);
-		    dstLine += pitch;
-		    srcLine += glyphslot->bitmap.pitch;
-		}
-	    }
-	    break;
-	default:
-	    if (XftDebug() & XFT_DBG_GLYPH)
-		printf ("glyph %d is not in a usable format\n",
-			(int) glyphindex);
-	    continue;
-	}
+        width  = ftbit->width;
+        height = ftbit->rows;
+        pitch  = (width+3) & ~3;
 	
 	if (XftDebug() & XFT_DBG_GLYPH)
 	{
@@ -423,29 +602,72 @@
 		int		x, y;
 		unsigned char	*line;
 
-		line = bufBitmap;
-		for (y = 0; y < height * vmul; y++)
+                line = ftbit->buffer;
+
+                if (ftbit->pitch < 0)
+                  line -= ftbit->pitch*(height-1);
+
+                for (y = 0; y < height; y++)
 		{
 		    if (font->info.antialias) 
 		    {
-			static char    den[] = { " .:;=+*#" };
-			for (x = 0; x < pitch; x++)
+                        static const char    den[] = { " .:;=+*#" };
+                        for (x = 0; x < width; x++)
 			    printf ("%c", den[line[x] >> 5]);
 		    }
 		    else
 		    {
-			for (x = 0; x < pitch * 8; x++)
+                        for (x = 0; x < width * 8; x++)
 			{
 			    printf ("%c", line[x>>3] & (1 << (x & 7)) ? '#' : ' ');
 			}
 		    }
 		    printf ("|\n");
-		    line += pitch;
+                    line += ftbit->pitch;
 		}
 		printf ("\n");
 	    }
 	}
 
+        size = _compute_xrender_bitmap_size( &local, glyphslot, mode );
+        if ( size < 0 )
+            continue;
+
+        xftg->metrics.width  = local.width;
+	xftg->metrics.height = local.rows;
+	xftg->metrics.x      = - glyphslot->bitmap_left;
+	xftg->metrics.y      =   glyphslot->bitmap_top;
+	    
+	    /*
+	 * If the glyph is relatively large (> 1% of server memory),
+	 * don't send it until necessary
+	     */
+	if (!need_bitmaps && size > info->max_glyph_memory / 100)
+	    continue;
+
+	/*
+	 * Make sure there's enough buffer space for the glyph
+	 */
+	if (size > bufSize)
+	    {
+	    if (bufBitmap != bufLocal)
+		free (bufBitmap);
+	    bufBitmap = (unsigned char *) malloc (size);
+	    if (!bufBitmap)
+		    continue;
+	    bufSize = size;
+	    }
+	memset (bufBitmap, 0, size);
+
+        local.buffer = bufBitmap;
+	    
+        _fill_xrender_bitmap( &local, glyphslot, mode,
+                              (font->info.rgba == FC_RGBA_BGR  ||
+                               font->info.rgba == FC_RGBA_VBGR ) );
+	/*
+	 * Copy or convert into local buffer
+	 */
+
 	/*
 	 * Use the glyph index as the wire encoding; it
 	 * might be more efficient for some locales to map
@@ -455,121 +677,23 @@
 	 */
 	glyph = (Glyph) glyphindex;
 
-	if (subpixel)
-	{
-	    int		    x, y;
-	    unsigned char   *in_line, *out_line, *in;
-	    unsigned int    *out;
-	    unsigned int    red, green, blue;
-	    int		    rf, gf, bf;
-	    int		    s;
-	    int		    o, os;
-	    
-	    /*
-	     * Filter the glyph to soften the color fringes
-	     */
-	    widthrgba = width;
-	    pitchrgba = (widthrgba * 4 + 3) & ~3;
-	    sizergba = pitchrgba * height;
-
-	    os = 1;
-	    switch (font->info.rgba) {
-	    case FC_RGBA_VRGB:
-		os = pitch;
-	    case FC_RGBA_RGB:
-	    default:
-		rf = 0;
-		gf = 1;
-		bf = 2;
-		break;
-	    case FC_RGBA_VBGR:
-		os = pitch;
-	    case FC_RGBA_BGR:
-		bf = 0;
-		gf = 1;
-		rf = 2;
-		break;
-	    }
-	    if (sizergba > bufSizeRgba)
-	    {
-		if (bufBitmapRgba != bufLocalRgba)
-		    free (bufBitmapRgba);
-		bufBitmapRgba = (unsigned char *) malloc (sizergba);
-		if (!bufBitmapRgba)
-		    continue;
-		bufSizeRgba = sizergba;
-	    }
-	    memset (bufBitmapRgba, 0, sizergba);
-	    in_line = bufBitmap;
-	    out_line = bufBitmapRgba;
-	    for (y = 0; y < height; y++)
-	    {
-		in = in_line;
-		out = (unsigned int *) out_line;
-		in_line += pitch * vmul;
-		out_line += pitchrgba;
-		for (x = 0; x < width * hmul; x += hmul)
-		{
-		    red = green = blue = 0;
-		    o = 0;
-		    for (s = 0; s < 3; s++)
-		    {
-			red += filters[rf][s]*in[x+o];
-			green += filters[gf][s]*in[x+o];
-			blue += filters[bf][s]*in[x+o];
-			o += os;
-		    }
-		    red = red / 65536;
-		    green = green / 65536;
-		    blue = blue / 65536;
-		    *out++ = (green << 24) | (red << 16) | (green << 8) | blue;
-		}
-	    }
-	    
-	    xftg->glyph_memory = sizergba + sizeof (XftGlyph);
-	    if (font->format)
+	xftg->glyph_memory = size + sizeof (XftGlyph);
+ 	    if (font->format)
 	    {
 		if (!font->glyphset)
 		    font->glyphset = XRenderCreateGlyphSet (dpy, font->format);
-		if (ImageByteOrder (dpy) != XftNativeByteOrder ())
-		    XftSwapCARD32 ((CARD32 *) bufBitmapRgba, sizergba >> 2);
-		XRenderAddGlyphs (dpy, font->glyphset, &glyph,
-				  &xftg->metrics, 1, 
-				  (char *) bufBitmapRgba, sizergba);
-	    }
-	    else
-	    {
-		if (sizergba)
-		{
-		    xftg->bitmap = malloc (sizergba);
-		    if (xftg->bitmap)
-			memcpy (xftg->bitmap, bufBitmapRgba, sizergba);
-		}
-		else
-		    xftg->bitmap = NULL;
-	    }
-	}
-	else
-	{
-	    xftg->glyph_memory = size + sizeof (XftGlyph);
-	    if (font->format)
-	    {
-		/*
-		 * swap bit order around; FreeType is always MSBFirst
-		 */
-		if (!font->info.antialias)
+	    if ( mode == FT_RENDER_MODE_MONO )
 		{
+		  /* swap bits in each byte */
 		    if (BitmapBitOrder (dpy) != MSBFirst)
 		    {
-			unsigned char   *line;
-			unsigned char   c;
-			int		    i;
+		      unsigned char   *line = (unsigned char*)bufBitmap;
+		      int             i = size;
 
-			line = (unsigned char *) bufBitmap;
-			i = size;
 			while (i--)
 			{
-			    c = *line;
+			  int  c = *line;
+
 			    c = ((c << 1) & 0xaa) | ((c >> 1) & 0x55);
 			    c = ((c << 2) & 0xcc) | ((c >> 2) & 0x33);
 			    c = ((c << 4) & 0xf0) | ((c >> 4) & 0x0f);
@@ -577,8 +701,12 @@
 			}
 		    }
 		}
-		if (!font->glyphset)
-		    font->glyphset = XRenderCreateGlyphSet (dpy, font->format);
+            else if ( mode != FT_RENDER_MODE_NORMAL )
+            {
+                /* invert ARGB <=> BGRA */
+                if (ImageByteOrder (dpy) != XftNativeByteOrder ())
+                    XftSwapCARD32 ((CARD32 *) bufBitmap, size >> 2);
+            }
 		XRenderAddGlyphs (dpy, font->glyphset, &glyph,
 				  &xftg->metrics, 1, 
 				  (char *) bufBitmap, size);
@@ -594,7 +722,7 @@
 		else
 		    xftg->bitmap = NULL;
 	    }
-	}
+
 	font->glyph_memory += xftg->glyph_memory;
 	info->glyph_memory += xftg->glyph_memory;
 	if (XftDebug() & XFT_DBG_CACHE)
@@ -605,8 +733,6 @@
     }
     if (bufBitmap != bufLocal)
 	free (bufBitmap);
-    if (bufBitmapRgba != bufLocalRgba)
-	free (bufBitmapRgba);
     XftUnlockFace (&font->public);
 }
 
diff -Naur libXft-2.1.14.orig/src/xftint.h libXft-2.1.14/src/xftint.h
--- libXft-2.1.14.orig/src/xftint.h	2010-02-20 14:41:32.000000000 +0100
+++ libXft-2.1.14/src/xftint.h	2010-02-20 14:47:04.000000000 +0100
@@ -145,6 +145,7 @@
     FcBool		antialias;	/* doing antialiasing */
     FcBool		embolden;	/* force emboldening */
     int			rgba;		/* subpixel order */
+    int			lcd_filter;	/* lcd filter */
     FT_Matrix		matrix;		/* glyph transformation matrix */
     FcBool		transform;	/* non-identify matrix? */
     FT_Int		load_flags;	/* glyph load flags */
diff -Naur libXft-2.1.14.orig/xft.pc.in libXft-2.1.14/xft.pc.in
--- libXft-2.1.14.orig/xft.pc.in	2010-02-20 14:41:32.000000000 +0100
+++ libXft-2.1.14/xft.pc.in	2010-02-20 14:46:46.000000000 +0100
@@ -6,7 +6,7 @@
 Name: Xft
 Description: X FreeType library
 Version: @VERSION@
-Requires: xproto, xrender, fontconfig, freetype2
+Requires: xproto
 Requires.private: xrender, fontconfig, freetype2
 Cflags: -I${includedir}
 Libs: -L${libdir} -lXft
